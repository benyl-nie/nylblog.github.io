<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>react14to16 | 玉玲～</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">react14to16</h1><a id="logo" href="/.">玉玲～</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">react14to16</h1><div class="post-meta">Aug 14, 2019<span> | </span><span class="category"><a href="/categories/react/">react</a></span></div><div class="post-content"><p>看了最近一篇微信订阅号推送的文章，感觉很不错，摘抄下来方便以后查看，摘自 <a href="https://mp.weixin.qq.com/s/iZqV6GAi5zyX5P48hR4VLA" target="_blank" rel="noopener">你需要掌握的 21 个 React 性能优化技巧</a></p>
<a id="more"></a>
<blockquote>
<p>React 为高性能应用设计提供了许多优化方案，本文列举了其中的一些最佳实践</p>
</blockquote>
<p>在以下场景中，父组件和子组件通常会重新渲染：</p>
<ul>
<li>在同一组件或父组件中调用 setState 时</li>
<li>在父级收到的“props”的值发生变化</li>
<li>调用组件中的 forceUpdate</li>
</ul>
<p>下面是提升 React 应用性能的 21 个技巧：</p>
<h3 id="1、使用纯组件"><a href="#1、使用纯组件" class="headerlink" title="1、使用纯组件"></a>1、使用纯组件</h3><p>如果 React 组件为相同的状态和 props 渲染相同的输出，则可以将 7 其 ️ 是为纯组件。</p>
<p>对于像 this 的类组件来说，React 提供了 PureComponent 基类。扩展 React.PureComponent 类的类组件被视为纯组件。<br>它与普通组件时一样的，只是 PureComponents 负责 shouldComponentUpdate— 他对状态和 props 数据进行浅层比较（shallow comparision）.</p>
<p>如果先前的状态和 props 数据与下一个 props 数据或者状态相同，则组件不会重新渲染。</p>
<ul>
<li>什么是浅层渲染？<blockquote>
<p>在对比先前的 props 和状态与下一个 props 和状态时，浅层比较将检查他们的基元是否有相同的值（例如：1 等于 1 或真等于真），还会检查更复杂的 Javascript 值（如对象和数组）之间的引用是否相同</p>
</blockquote>
</li>
</ul>
<p>比较基元和对象引用的开销比更新组件视图要低。<br>因此，查找状态和 props 值的变化会比不必要的更新更快。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'Mayank'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: <span class="string">'Mayank</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;, 1000);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  componentDidMount() &#123;</span></span><br><span class="line"><span class="string">    this.updateState();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Render called Again<span class="string">');</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;RegularChiildComponent name=&#123;this.state.name&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;PureChildComponet name=&#123;this.state.name&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class RegularChildComponent extends React.Component &#123;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Regular Compoment Rendered..<span class="string">');</span></span><br><span class="line"><span class="string">    return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class PureChildComponent extends React.PureComponent &#123;</span></span><br><span class="line"><span class="string">  // Pure Component are the component that do not re-render if the state data or props data is still the same</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Pure Component are Rendered...<span class="string">');</span></span><br><span class="line"><span class="string">    return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，状态被传播到自组件 RegularChildComponent 和 PureChildComponent。PureChildComponent 是一个纯组件。</p>
<p>setState 在一秒的间隔之后被调用，这将重新触发组件的视图渲染。由于初始 props 和新 props 的值相同，因此组件(PureChildComponent) 不会被重新渲染<br>状态的浅层比较表明 props 或状态的数据没有变化，因此不需要渲染数据，从而提高了性能</p>
<h3 id="2、使用-React-memo-进行组件记忆"><a href="#2、使用-React-memo-进行组件记忆" class="headerlink" title="2、使用 React.memo 进行组件记忆"></a>2、使用 React.memo 进行组件记忆</h3><p>React.memo 是一个高阶组件。</p>
<p>它很像 PureComponent,但 PureComponent 属于 Component 的类实现，而‘memo’则用于创建函数组件。</p>
<p>这里与纯组件类似，如果输入 props 相同则跳过组件渲染，从而提升组件性能。</p>
<p>它会记忆上次某个输入 props 的执行输出并提升应用性能。即使在这些组件中比较也是浅层的。</p>
<p>你还可以为这个组件传递自定义比较逻辑。</p>
<p>用户可以用自定义逻辑深度对比(deep comparision)对象。如果比较函数返回 false 则重新渲染组件，否则就不会重新渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomisedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;User name: &#123;props.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;b&gt;User age: &#123;props.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;b&gt;User designation: &#123;props.designation&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the compoment below is rhe optimised version for the Default component</span></span><br><span class="line"><span class="comment">// The Component will not re-render if same props value for 'name' property</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memoComponet = React.mmeo(CustomisedComponent);</span><br></pre></td></tr></table></figure>
<p>上面的组件将对前后两个 props 的值进行浅层比较<br>如果我们将对象引用作为 props 传递给 memo 组件，则需要一些自定义登陆以进行比较。在这种情况下，我们可以将比较函数作为第二个参数传递给 React.memo 函数<br>假设 props 值（user）是一个对象引用，包含特定用户的 name，age 和 designation。<br>这种情况下需要进行深入比较，我们可以创建一个自定义函数，查找前后两个 props 值的 name,age 和 designation 的值，如果它们不相同则返回 false<br>这样，即使我们将参考数据作为 memo 组件的输入，组件也不会重新渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following function takes 'user' Object as input parameter in props</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomisedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;User name: &#123;props.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;b&gt;User age: &#123;props.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;b&gt;User designation: &#123;props.designation&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userComparator</span>(<span class="params">previonProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previonProps.user.name == nextProps.user.name ||</span><br><span class="line">    previonProps.user.age == nextProps.user.age ||</span><br><span class="line">    previonProps.user.designation == nextProps.user.designation</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memoComponent = React.memo(CustomisedComponent, userComparator);</span><br></pre></td></tr></table></figure>
<p>上面的代码提供了用于比较的自定义逻辑</p>
<h3 id="3、使用-shouldComponentUpdate-生命周期函数"><a href="#3、使用-shouldComponentUpdate-生命周期函数" class="headerlink" title="3、使用 shouldComponentUpdate 生命周期函数"></a>3、使用 shouldComponentUpdate 生命周期函数</h3><blockquote>
<p>这是在重新渲染组件之前触发的其中一个生命周期事件</p>
</blockquote>
<p>可以利用此事件来决定何时需要重新渲染组件，如果组件 props 更改或调用 setState,则此函数返回一个 Boolean 值。<br>在这两种情况下组件都会重新渲染。我们可以在这个生命周期事件中放置一个自定义逻辑，以决定是否调用组件的 render 函数</p>
<p>这个函数将 nextState 和 nextProps 作为输入，并可将其与当前 props 和状态做对比，以决定是否需要重新渲染。<br>比如说我想再网页上显示员工的详细资料。每位员工都包含多个属性，如姓名，年龄，牌号，薪水，当前经理，前任经理，奖金等。</p>
<p>我想只在网页上渲染员工的姓名和年龄。员工的牌号会在某时刻更新。</p>
<p>由于员工牌号不在视图内，理想情况下视图是无需要更新的，我们可以在组件中添加自定义逻辑，哦安段是否需要组件更新视图</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ShouldComponentUpdateState</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'Mayank'</span>,</span><br><span class="line">      age: <span class="number">30</span>,</span><br><span class="line">      designation: <span class="string">'Architect</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ComponentDidMount() &#123;</span></span><br><span class="line"><span class="string">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">      this.setState(&#123;</span></span><br><span class="line"><span class="string">        designation: '</span>hhhhhhh<span class="string">'</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  shouleComponentUpdate(nextProps, nextState) &#123;</span></span><br><span class="line"><span class="string">    if (nextState.age != this.state.age || nextState.name != this.state.name) return true;</span></span><br><span class="line"><span class="string">    return false;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">         &lt;b&gt;User name: &#123;props.name&#125;&lt;/b&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;User age: &#123;props.age&#125;&lt;/b&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里即使组件中 designation 发生变化也不会影响应用的视图。</p>
<p>调用 setState 时组件会重新渲染，但因为 designation 更改不会改变/影响组件的视图，因此在更改 designation 时重新渲染组件会带来额外开销。</p>
<p>为了避免这种开销。我们可以使用自定义逻辑检查 name 或 age 是否更新，因为视图仅受他们的影响</p>
<p>shouleComponentUpdate 将输入参数作为状态和 props 的新值</p>
<p>我们可以比较 name 和 age 的当前值和新值，有任何一个发生变化就可以触发重新渲染。</p>
<p>从 shouleComponentUpdate 传递 true 就意味着可以重新渲染组件，反之亦然。所以正确使用 shouleComponentUpdate 就可以优化应用组件的性能。</p>
<p>对比初始状态和 props 后我们就可以决定祖耀重新渲染组件。这样就可以减少重新渲染的需求来提升性能。</p>
<h3 id="4-懒加载组件"><a href="#4-懒加载组件" class="headerlink" title="4. 懒加载组件"></a>4. 懒加载组件</h3><p>导入多个文件合并到一个文件中的过程叫打包，使应用不必导入大量外部文件。</p>
<p>所有主要组件和外部依赖项都合并为一个文件，通过网络传送出去以启动并运行 Web 应用。</p>
<p>这样可以节省大量网络调用，但这个文件会变得很大，消耗大量网络带宽。</p>
<p>应用需要等待这个文件的加载和执行，所以传输延迟会带来严重的影响。</p>
<p>为了解决这个问题，我们引入代码拆分的概念。</p>
<p>像 webpack 这样的打包器支持就支持代码拆分，它可以为应用创建多个包，并在运行时动态加载，减少初始包的大小。</p>
<p>为此我们使用 Suspense 和 lazy</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CallingLazyComponents</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> ComponentToLazyLoad = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.name == <span class="string">"Mayank"</span>) &#123;</span><br><span class="line">      ComponentToLazyLoad = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./mayankComponent"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.props.name == <span class="string">"Anshul"</span>) &#123;</span><br><span class="line">      ComponentToLazyLoad = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./anshulComponent"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;This is the Base User: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/</span>div&gt;&#125;&gt;</span><br><span class="line">          &lt;ComponentToLazyLoad /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中有一个条件语句，它查找 props 值，并根据指定的条件加载主组件中的两个组件。</p>
<p>我们可以按需懒惰加载这些拆分出来的组件，增强应用的整体性能。</p>
<p>假设有两个组件 WelcomeComponent 或 GuestComponents，我们根据用户是否登录而渲染其中一个。</p>
<p>我们可以根据具体的条件延迟组件加载，无需一开始就加载两个组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSalutation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.username !== <span class="string">""</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> WelcomeComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./welcomeComponent"</span>));</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;WelcomeComponent /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> GuestComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./guestComponent"</span>));</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;GuestComponent /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们没有预加载 WelcomeCompoment 和 GuestComponents 这两个组件，而是进行一个条件检查。</p>
<p>如果用户名存在（或相反），我们就根据指定的条件决定将某个组件作为单独的包加载。</p>
<ul>
<li>这个方法的好处<blockquote>
<p>1、主包体积变小，消耗的网络传输时间更少。<br>2、动态单独加载的包比较小，可以迅速加载完成。</p>
</blockquote>
</li>
</ul>
<p>我们可以分析应用来决定懒加载哪些组件，从而减少应用的初始加载时间。</p>
<h3 id="5-使用-React-Fragments-避免额外标记"><a href="#5-使用-React-Fragments-避免额外标记" class="headerlink" title="5. 使用 React Fragments 避免额外标记"></a>5. 使用 React Fragments 避免额外标记</h3><p>使用 Fragments 减少了包含的额外标记数量，这些标记只是为了满足在 React 组件中具有公共父级的要求。</p>
<p>用户创建新组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签。所以我们经常在组件顶部添加额外标签，例如：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSNLsyKLGfsAGibof63PPoMe7dHCicaMjtUyM7IficHJianqDaROTJg0zUQ9A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="举例图片"></p>
<p>在上面指定的组件中，我们需要一个额外的标签为要渲染的组件提供公共父级。</p>
<p>除了充当组件的父标签之外，这个额外的 div 没有其他用途。</p>
<p>在顶层有多个标签会导致以下错误：<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSNwXEYVZC2ibgpw4ibfBWQxtRNaoBYDsn7JuySLDBETXaDKwXQsYQAficHw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="举例图片2"><br>要解决此问题，我们可以将元素包含在片段（fragement）中。</p>
<p>片段不会向组件引入任何额外标记，但它仍然为两个相邻标记提供父级，因此满足在组件顶级具有单个父级的条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedRoutingComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;This is the Header Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;Welcome To Demo Page&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码没有额外的标记，因此节省了渲染器渲染额外元素的工作量。</p>
<p>详细信息参考:<br><a href="https://github.com/facebook/react/issues/2127" target="_blank" rel="noopener">https://github.com/facebook/react/issues/2127</a></p>
<h3 id="6-不要使用内联函数定义"><a href="#6-不要使用内联函数定义" class="headerlink" title="6. 不要使用内联函数定义"></a>6. 不要使用内联函数定义</h3><p>如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例。</p>
<p>当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。</p>
<p>因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineFunctionComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="button"</span></span><br><span class="line"><span class="regexp">          onClick=&#123;e =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123; inputValue: e.target.value &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">          value="Click For Inline Function"</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的函数创建了内联函数。每次调用 render 函数时都会创建一个函数的新实例，render 函数会将该函数的新实例绑定到该按钮。</p>
<p>此外最后一个函数实例会被垃圾回收，大大增加了 React 应用的工作量。</p>
<p>所以不要用内联函数，而是在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 render 时就不会创建单独的函数实例了，参考组件如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineFunctionComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  setNewStateData = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="button"</span></span><br><span class="line"><span class="regexp">          onClick=&#123;this.setNewStateData&#125;</span></span><br><span class="line"><span class="regexp">          value="Click For Inline Function"</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-避免-componentWillMount-中的异步请求"><a href="#7-避免-componentWillMount-中的异步请求" class="headerlink" title="7. 避免 componentWillMount()中的异步请求"></a>7. 避免 componentWillMount()中的异步请求</h3><p>componentWillMount 是在渲染组件之前调用的。</p>
<p>这个函数用的不多，可用来配置组件的初始配置，但使用 constructor 方法自己也能做到。</p>
<p>该方法无法访问 DOM 元素，因为组件还没挂载上来。</p>
<p>一些开发人员认为这个函数可以用来做异步数据 API 调用，但其实这没什么好处。</p>
<p>由于 API 调用是异步的，因此组件在调用 render 函数之前不会等待 API 返回数据。于是在初始渲染中渲染组件时没有任何数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingAsyncInComponentWillMount</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      userData: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    axios.get(<span class="string">"someResourceUrl"</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        userData: data</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b&gt;UserName: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;UserAge: &#123;this.state.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们正在进行异步调用以获取数据。由于数据调用是异步的，需要一段时间才能获取到。</p>
<p>在检索数据时 React 会触发组件的 render 函数。因此第一个调用的渲染仍然不包含它所需的数据。</p>
<p>这样一开始渲染组件没有数据，然后检索数据，调用 setState，还得重新渲染组件。在 componentWillMount 阶段进行 AJAX 调用没有好处可言。</p>
<p>我们应避免在此函数中发出 Async 请求。这些函数和调用可以延迟到 componentDidMount 生命周期事件里。</p>
<p><strong>注意</strong>：React 16.3 不推荐使用 componentWillMount。如果你使用的是最新版本的 React，请避免使用这个生命周期事件。</p>
<h3 id="8-在-Constructor-的早期绑定函数"><a href="#8-在-Constructor-的早期绑定函数" class="headerlink" title="8. 在 Constructor 的早期绑定函数"></a>8. 在 Constructor 的早期绑定函数</h3><p>当我们在 React 中创建函数时，我们需要使用 bind 关键字将函数绑定到当前上下文。</p>
<p>绑定可以在构造函数中完成，也可以在我们将函数绑定到 DOM 元素的位置上完成。</p>
<p>两者之间似乎没有太大差异，但性能表现是不一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Click"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们在 render 函数的绑定期间将函数绑定到按钮上。</p>
<p>上面代码的问题在于，每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleButtonClick = <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click"</span> onClick=&#123;<span class="keyword">this</span>.handleButtonClick&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>最好在构造函数调用期间使用绑定到当前上下文的函数覆盖 handleButtonClick 函数。</p>
<p>这将减少将函数绑定到当前上下文的开销，无需在每次渲染时重新创建函数，从而提高应用的性能。</p>
<h3 id="9-箭头函数与构造函数中的绑定"><a href="#9-箭头函数与构造函数中的绑定" class="headerlink" title="9. 箭头函数与构造函数中的绑定"></a>9. 箭头函数与构造函数中的绑定</h3><p>处理类时的标准做法就是使用箭头函数。使用箭头函数时会保留执行的上下文。</p>
<p>我们调用它时不需要将函数绑定到上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click"</span> onClick=&#123;<span class="keyword">this</span>.handleButtonClick&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>箭头函数好处多多，但也有缺点。</p>
<blockquote>
<p>当我们添加箭头函数时，该函数被添加为对象实例，而不是类的原型属性。这意味着如果我们多次复用组件，那么在组件外创建的每个对象中都会有这些函数的多个实例。<br>每个组件都会有这些函数的一份实例，影响了可复用性。此外因为它是对象属性而不是原型属性，所以这些函数在继承链中不可用。</p>
</blockquote>
<p>因此箭头函数确实有其缺点。实现这些函数的最佳方法是在构造函数中绑定函数，如上所述。</p>
<h3 id="10-避免使用内联样式属性"><a href="#10-避免使用内联样式属性" class="headerlink" title="10. 避免使用内联样式属性"></a>10. 避免使用内联样式属性</h3><p>使用内联样式时浏览器需要花费更多时间来处理脚本和渲染，因为它必须映射传递给实际 CSS 属性的所有样式规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineStyledComponents</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b style=&#123;&#123; <span class="attr">backgroundColor</span>: <span class="string">"blue"</span> &#125;&#125;&gt;Welcome to Sample Page&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面创建的组件中，我们将内联样式附加到组件。添加的内联样式是 JavaScript 对象而不是样式标记。</p>
<p>样式 backgroundColor 需要转换为等效的 CSS 样式属性，然后才应用样式。这样就需要额外的脚本处理和 JS 执行工作。</p>
<p>更好的办法是将 CSS 文件导入组件。</p>
<h3 id="11-优化-React-中的条件渲染"><a href="#11-优化-React-中的条件渲染" class="headerlink" title="11. 优化 React 中的条件渲染"></a>11. 优化 React 中的条件渲染</h3><p>安装和卸载 React 组件是昂贵的操作。为了提升性能，我们需要减少安装和卸载的操作。</p>
<p>很多情况下在我们可能会渲染或不渲染特定元素，这时可以用条件渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AdminHeaderComponent <span class="keyword">from</span> <span class="string">"./AdminHeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> HeaderComponent <span class="keyword">from</span> <span class="string">"./HeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> ContentComponent <span class="keyword">from</span> <span class="string">"./ContentComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRendering</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.name == <span class="string">"Mayank"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt;</span><br><span class="line">          &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125; else &#123;</span></span><br><span class="line"><span class="regexp">      return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;HeaderComponent&gt;&lt;/</span>HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中有一个条件语句，让组件根据指定的条件渲染。如果状态包含名称值 Mayank，则不会渲染 AdminHeaderComponent。</p>
<p>条件运算符和 if else 条件似乎没问题，但后面的代码有性能问题，需要分析一下。</p>
<p>每次调用 render 函数，并且值在 Mayank 和另一个值之间切换时，都会执行不同的 if else 语句。</p>
<p>diffing 算法会运行一个检查，比较每个位置的元素类型。在 diffing 期间，它看到 AdminHeaderComponent 不可用，并且需要渲染的第一个组件是 HeaderComponent。</p>
<p>React 将观察元素的位置。它看到位置 1 和位置 2 的组件已更改并将卸载组件。</p>
<p>组件 HeaderComponent 和 ContentComponent 将在位置 1 和位置 2 卸载并重新安装。其实这是用不着的，因为这些组件没有更改，这是一项昂贵的操作。优化方案如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AdminHeaderComponent <span class="keyword">from</span> <span class="string">"./AdminHeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> HeaderComponent <span class="keyword">from</span> <span class="string">"./HeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> ContentComponent <span class="keyword">from</span> <span class="string">"./ContentComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRendering</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.name == <span class="string">"Mayank"</span> &amp;&amp; (</span><br><span class="line">          &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">        &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，当 name 不是 Mayank 时，React 在位置 1 处放置 null。</p>
<p>开始 DOM diffing 时，位置 1 的元素从 AdminHeaderComponent 变为 null，但位置 2 和位置 3 的组件保持不变。</p>
<p>由于元素没变，因此组件不会卸载，减少了不必要的操作。</p>
<p>详细信息请参阅:<br><a href="https://medium.com/@cowi4030/optimizing-conditional-rendering-in-react-3fee6b197a20" target="_blank" rel="noopener">https://medium.com/@cowi4030/optimizing-conditional-rendering-in-react-3fee6b197a20</a></p>
<h3 id="12-不要在-render-方法中导出数据"><a href="#12-不要在-render-方法中导出数据" class="headerlink" title="12. 不要在 render 方法中导出数据"></a>12. 不要在 render 方法中导出数据</h3><p>Render 方法是 React 开发人员最熟悉的生命周期事件。</p>
<p>和其他生命周期事件不一样的是，我们的核心原则是将 render() 函数作为纯函数。</p>
<ul>
<li>纯函数对 render 方法意味着什么？<blockquote>
<p>纯函数意味着我们应该确保 setState 和查询原生 DOM 元素等任何可以修改应用状态的东西不会被调用。<br>该函数永远不该更新应用的状态。<br>更新组件状态的问题在于，当状态更新时会触发另一个 render 循环，后者在内部会再触发一个 render 循环，以此类推。</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderFunctionOptimization</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.state.name + <span class="string">"_"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;User Name: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，每次调用 render 函数时都会更新状态。状态更新后组件将立即重新渲染。因此更新状态会导致 render 函数的递归调用。</p>
<p>render 函数应保持纯净，以确保组件以一致的方式运行和渲染。</p>
<h3 id="13-为组件创建错误边界"><a href="#13-为组件创建错误边界" class="headerlink" title="13. 为组件创建错误边界"></a>13. 为组件创建错误边界</h3><p>组件渲染错误是很常见的情况。</p>
<p>在这种情况下，组件错误不应该破坏整个应用。创建错误边界可避免应用在特定组件发生错误时中断。</p>
<p>错误边界是一个 React 组件，可以捕获子组件中的 JavaScript 错误。我们可以包含错误、记录错误消息，并为 UI 组件故障提供回退机制。</p>
<p>错误边界是基于高阶组件的概念。</p>
<p>详细信息参阅:<br><a href="https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634" target="_blank" rel="noopener">https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634</a></p>
<p>错误边界涉及一个高阶组件，包含以下方法：static getDerivedStateFromError() 和 componentDidCatch()。</p>
<p>static 函数用于指定回退机制，并从收到的错误中获取组件的新状态。</p>
<p>componentDidCatch 函数用来将错误信息记录到应用中。</p>
<p>下面是代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundaries</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      hasErrors: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">"Component Did Catch Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">"Get Derived State From Error"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      hasErrors: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasErrors === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;div&gt;This is a Error&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ShowData name=<span class="string">"Mayank"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export class ShowData extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor() &#123;</span></span><br><span class="line"><span class="regexp">    super();</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      name: "Mayank"</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  changeData = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;</span></span><br><span class="line"><span class="regexp">      name: "Anshul"</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    if (this.state.name === "Anshul") &#123;</span></span><br><span class="line"><span class="regexp">      throw new Error("Sample Error");</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;This is the Child Component &#123;this.state.name&#125;&lt;/</span>b&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.changeData&#125;</span><br><span class="line">          value=<span class="string">"Click To Throw Error"</span></span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当 name 更新为 Anshul 时，上面的代码会抛出错误。</p>
<p>组件 ShowData 是 ErrorBoundaries 组件内的嵌入。</p>
<p>因此，如果错误是从 ShowData 函数内抛出的，则它会被父组件捕获，我们使用 static getDerivedStateFromError 函数和 componentDidCatch 生命周期事件中的日志数据部署回退 UI。</p>
<h3 id="14-组件的不可变数据结构"><a href="#14-组件的不可变数据结构" class="headerlink" title="14. 组件的不可变数据结构"></a>14. 组件的不可变数据结构</h3><p>React 的灵魂是函数式编程。如果我们希望组件能一致工作，则 React 组件中的状态和 props 数据应该是不可变的。</p>
<p>对象的突变可能导致输出不一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line">expoort <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableComponentData</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        name: <span class="string">"Mayank"</span>,</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">        designation: <span class="string">"Software Architect"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateUser() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        name: <span class="string">"OtherUser"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nextState.userInfo != <span class="keyword">this</span>.state.userInfo) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b&gt;User Name: &#123;<span class="keyword">this</span>.state.userName&#125;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如上所示。在 shouldComponentUpdate 函数中我们指定，如果 userInfo 的初始值与 userInfo 的新值不同，则应该重新渲染该组件；反之不应重新渲染组件。</p>
<p>详细信息参阅:<br><a href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc" target="_blank" rel="noopener">https://blog.logrocket.com/immutability-in-react-ebe55253a1cc</a></p>
<h3 id="15-使用唯一键迭代"><a href="#15-使用唯一键迭代" class="headerlink" title="15. 使用唯一键迭代"></a>15. 使用唯一键迭代</h3><p>当我们需要渲染项目列表时应该为项目添加一个键。</p>
<p>键可以用来识别已更改、添加或删除的项目。键为元素提供了稳定的标识。一个键应该对应列表中的唯一一个元素。</p>
<p>如果开发人员没有为元素提供键，则它将 index 作为默认键。在下面的代码中我们默认不添加任何键，因此 index 将用作列表的默认键。</p>
<p>使用 index 作为键就不会出现标识不唯一的问题了，因为 index 只会标识所渲染的组件。</p>
<blockquote>
<p>我们可以在以下场景中使用 index 作为键：</p>
</blockquote>
<ul>
<li>列表项是静态的，项目不随时间变化。</li>
<li>Items 没有唯一 ID。</li>
<li>List 永远不会重新排序或过滤。</li>
<li>不会从顶部或中间添加或删除项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">export default class ComponentRecreation extends React.Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            inputName: &quot;&quot;,</span><br><span class="line">            arrayData: [&quot;Mayank&quot;, &quot;Meha&quot;, &quot;Anshul&quot;, &quot;Arjun&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateUserName(event) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            inputName: event.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addUserData() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            arrayData: [this.state.inputName, ...this.state.arrayData]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        var dataList = this.state.arrayData.map((data, index) =&gt; &#123;</span><br><span class="line">            return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">        &#125;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; value=&#123;this.state.inputName&#125; placeholder=&quot;Enter Unique Name&quot; onChange=&#123;this.updateUserName.bind(this)&#125; /&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; onClick=&#123;this.addUserData.bind(this)&#125; value=&quot;Click To Add&quot; /&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">                &lt;b&gt;List of Users: &lt;/b&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">                &#123;dataList&#125;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在列表中添加项目<br>使用 index 作为键会加大错误率并降低应用的性能。</p>
</blockquote>
<p>每当新元素添加到列表时，默认情况下 React 会同时遍历新创建的列表和旧列表，并在需要时进行突变。</p>
<p>在列表顶部添加一个新元素（包含 index 作为键）时，全部已有组件的索引都会更新。</p>
<p>索引更新后，之前键值为 1 的元素现在的键值变成了 2。更新所有组件会拖累性能。</p>
<p>上面的代码允许用户在列表顶部添加新项目。但在顶部插入元素后果最严重。因为顶部元素一变，后面所有的元素都得跟着改键值，从而导致性能下降。</p>
<p>因此，我们应该确保键值和元素一一对应不会变化。</p>
<ul>
<li><p>Key 不仅影响性能，更重要的作用是标识。随机分配和更改的值不算是标识。</p>
</li>
<li><p>我们得知道数据的建模方式才能提供合适的键值。如果你没有 ID，我建议使用某种哈希函数生成 ID。</p>
</li>
<li><p>我们在使用数组时已经有了内部键，但它们是数组中的索引。插入新元素时这些键是错误的</p>
</li>
</ul>
<p>详细信息请参阅：</p>
<ul>
<li><p><a href="https://reactjs.org/docs/reconciliation.html?#recursing-on-children" target="_blank" rel="noopener">https://reactjs.org/docs/reconciliation.html?#recursing-on-children</a></p>
</li>
<li><p><a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a></p>
</li>
</ul>
<h3 id="16-事件节流和防抖"><a href="#16-事件节流和防抖" class="headerlink" title="16. 事件节流和防抖"></a>16. 事件节流和防抖</h3><p>节流（throttling）和防抖（debouncing）可用来限制在指定时间内调用的事件处理程序的数量。</p>
<p>事件处理程序是响应不同事件（如鼠标单击和页面滚动）而调用的函数。事件触发事件处理程序的速率是不一样的。</p>
<p><strong>节流的概念</strong></p>
<blockquote>
<p>节流意味着延迟函数执行。<br>这些函数不会立即执行，在触发事件之前会加上几毫秒延迟。<br>比如在页面滚动时，我们不会过于频繁地触发滚动事件，而是将事件延迟一段时间以便将多个事件堆叠在一起。<br>它确保函数在特定时间段内至少调用一次。如果函数最近运行过了，它将阻止函数运行，确保函数以固定间隔定期运行。<br>当我们处理无限滚动并且当用户接近页面底部必须获取数据时，我们可以使用节流。<br>否则滚动到页面底部将触发多个事件，并且触发对网络的多次调用，从而导致性能问题。</p>
</blockquote>
<p><strong>防抖的概念</strong></p>
<blockquote>
<p>防抖是指在调用停止一段时间之前忽略事件处理程序调用。<br>假设我们有一个事件，有一秒钟的 debounce 时间。一旦用户停止触发事件，该事件的事件处理程序将在一秒钟后触发</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSN9L65kcvyr2sAH200o44aMSWnBbyb8IaV20sQ0dfyGkLOkOGG4YTrIA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="用例图"></p>
<blockquote>
<p>典型的例子是用户在自动填充搜索框中键入数据。<br>一旦用户停止键入，就会进行 AJAX 查询以从 API 获取数据。每次键入都进行 AJAX 调用就需要多次查询数据库。<br>因此，我们对该事件做 debounce，直到用户不再输入数据为止，从而减少网络调用并提升性能。<br>我们可以使用第三方库来实现和使用节流和防抖功能，例如 throttle-debounce。具体用法参阅:<br><a href="https://www.npmjs.com/package/throttle-debounce。" target="_blank" rel="noopener">https://www.npmjs.com/package/throttle-debounce。</a></p>
</blockquote>
<h3 id="17-使用-CDN"><a href="#17-使用-CDN" class="headerlink" title="17. 使用 CDN"></a>17. 使用 CDN</h3><p>谷歌、亚马逊和微软等公司提供了许多内容分发网络。</p>
<p>这些 CDN 是可在你的应用中使用的外部资源。我们甚至可以创建私有 CDN 并托管我们的文件和资源。</p>
<p>使用 CDN 有以下好处：</p>
<ul>
<li><strong>不同的域名。</strong> 浏览器限制了单个域名的并发连接数量，具体取决于浏览器设置。假设允许的并发连接数为 10。如果要从单个域名中检索 11 个资源，那么同时完成的只有 10 个，还有 1 个需要再等一会儿。CDN 托管在不同的域名 / 服务器上。因此资源文件可以分布在不同的域名中，提升了并发能力。</li>
<li><strong>文件可能已被缓存。</strong> 有很多网站使用这些 CDN，因此你尝试访问的资源很可能已在浏览器中缓存好了。这时应用将访问文件的已缓存版本，从而减少脚本和文件执行的网络调用和延迟，提升应用性能。</li>
<li><strong>高容量基础设施。</strong> 这些 CDN 由大公司托管，因此可用的基础设施非常庞大。他们的数据中心遍布全球。向 CDN 发出请求时，它们将通过最近的数据中心提供服务，从而减少延迟。这些公司会对服务器做负载平衡，以确保请求到达最近的服务器并减少网络延迟，提升应用性能。</li>
</ul>
<p>如果担心安全性，可以使用私有 CDN。</p>
<h3 id="18-用-CSS-动画代替-JavaScript-动画"><a href="#18-用-CSS-动画代替-JavaScript-动画" class="headerlink" title="18. 用 CSS 动画代替 JavaScript 动画"></a>18. 用 CSS 动画代替 JavaScript 动画</h3><p>在 HTML 5 和 CSS 3 出现之前，动画曾经是 JavaScript 的专属，但随着 HTML 5 和 CSS 3 的引入情况开始变化。现在动画甚至可以由 CSS 3 来处理了。</p>
<blockquote>
<p>我们可以制定一些规则：</p>
</blockquote>
<ul>
<li>如果 CSS 可以实现某些 JS 功能，那就用 CSS。</li>
<li>如果 HTML 可以实现某些 JS 功能，那就用 HTML。</li>
</ul>
<blockquote>
<p>理由如下：</p>
</blockquote>
<ul>
<li>破损的 CSS 规则和样式不会导致网页损坏，而 JavaScript 则不然。</li>
<li>解析 CSS 是非常便宜的，因为它是声明性的。我们可以为样式并行创建内存中的表达，可以推迟样式属性的计算，直到元素绘制完成。</li>
<li>为动画加载 JavaScript 库的成本相对较高，消耗更多网络带宽和计算时间。</li>
<li>虽然 JavaScript 可以提供比 CSS 更多的优化，但优化过的 JavaScript 代码也可能卡住 UI 并导致 Web 浏览器崩溃。</li>
</ul>
<p>详细信息参阅:<br><a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript</a></p>
<h3 id="19-在-Web-服务器上启用-gzip-压缩"><a href="#19-在-Web-服务器上启用-gzip-压缩" class="headerlink" title="19. 在 Web 服务器上启用 gzip 压缩"></a>19. 在 Web 服务器上启用 gzip 压缩</h3><p>压缩是节省网络带宽和加速应用的最简单方法。</p>
<p>我们可以把网络资源压缩到更小的尺寸。Gzip 是一种能够快速压缩和解压缩文件的数据压缩算法。</p>
<p>它可以压缩几乎所有类型的文件，例如图像、文本、JavaScript 文件、样式文件等。Gzip 减少了网页需要传输到客户端的数据量。</p>
<p>当 Web 服务器收到请求时，它会提取文件数据并查找 Accept-Encoding 标头以确定如何压缩应用。</p>
<p>如果服务器支持 gzip 压缩，资源会被压缩后通过网络发送。每份资源的压缩副本（添加了 Content-Encoding 标头）指定使用 gzip 解压。</p>
<p>然后，浏览器将内容解压缩原始版本在渲染给用户。</p>
<p>只是 gzip 压缩需要付出成本，因为压缩和解压缩文件属于 CPU 密集型任务。但我们还是建议对网页使用 gzip 压缩。</p>
<p>详细信息参阅:<br><a href="https://royal.pingdom.com/can-gzip-compression-really-improve-web-performance" target="_blank" rel="noopener">https://royal.pingdom.com/can-gzip-compression-really-improve-web-performance</a></p>
<h3 id="20-使用-Web-Workers-处理-CPU-密集任务"><a href="#20-使用-Web-Workers-处理-CPU-密集任务" class="headerlink" title="20. 使用 Web Workers 处理 CPU 密集任务"></a>20. 使用 Web Workers 处理 CPU 密集任务</h3><p>JavaScript 是一个单线程应用，但在渲染网页时需要执行多个任务：</p>
<p>处理 UI 交互、处理响应数据、操纵 DOM 元素、启用动画等。所有这些任务都由单个线程处理。</p>
<p>可以使用 worker 来分担主线程的负载。</p>
<p>Worker 线程在后台运行，可以在不中断主线程的情况下执行多个脚本和 JavaScript 任务。</p>
<p>每当需要执行长时间的 CPU 密集任务时，可以使用 worker 在单独的线程上执行这些逻辑块。</p>
<p>它们在隔离环境中执行，并且使用进程间线程通信与主线程交互。主线程就可以腾出手来处理渲染和 DOM 操作任务。</p>
<p>详细信息参阅:<br><a href="https://medium.com/prolanceer/optimizing-react-app-performance-using-web-workers-79266afd4a7" target="_blank" rel="noopener">https://medium.com/prolanceer/optimizing-react-app-performance-using-web-workers-79266afd4a7</a></p>
<h3 id="21-React-组件的服务端渲染"><a href="#21-React-组件的服务端渲染" class="headerlink" title="21. React 组件的服务端渲染"></a>21. React 组件的服务端渲染</h3><p>服务端渲染可以减少初始页面加载延迟。</p>
<p>我们可以让网页从服务端加载初始页面，而不是在客户端上渲染。这样对 SEO 非常有利。</p>
<p>服务端渲染是指第一个组件显示的内容是从服务器本身发送的，而不是在浏览器级别操作。之后的页面直接从客户端加载。</p>
<p>这样我们就能把初始内容放在服务端渲染，客户端只按需加载部分页面。</p>
<blockquote>
<p>其好处包括：</p>
</blockquote>
<ul>
<li>性能：初始页面内容和数据是从服务器本身加载的，因此我们不需要添加加载器和下拉列表，而是等待初始页面加载完毕后再加载初始组件。</li>
<li>SEO 优化：爬虫在应用初始加载时查找页面内容。在客户端渲染时初始 Web 页面不包含所需的组件，这些组件需要等 React 脚本等文件加载完毕后才渲染出来</li>
</ul>
<p>服务端渲染还可以使用第三方库，如 Next.js。详细信息参阅: <a href="https://nextjs.org/" target="_blank" rel="noopener">https://nextjs.org/</a></p>
<p>这里有服务端渲染的示例项目：<a href="https://github.com/Mayankgupta688/reactServerRendering。只需从项目存储库执行以下步骤即可运行应用" target="_blank" rel="noopener">https://github.com/Mayankgupta688/reactServerRendering。只需从项目存储库执行以下步骤即可运行应用</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>这个应用中“pages”文件夹里的文件是可以用服务端渲染加载的初始 URL</p>
<blockquote>
<p>参考</p>
</blockquote>
<ul>
<li>示例代码 GitHub 仓库: <a href="https://github.com/Mayankgupta688/react-demos" target="_blank" rel="noopener">https://github.com/Mayankgupta688/react-demos</a></li>
<li>英文原文:<a href="https://medium.com/better-programming/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349" target="_blank" rel="noopener">https://medium.com/better-programming/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349</a></li>
</ul>
</div><div class="tags"><a href="/tags/React-性能优化-javascript/">React 性能优化 javascript</a></div><div class="post-nav"><a class="pre" href="/2019/08/14/html转markdown/">html转markdown</a><a class="next" href="/2019/07/01/js原生array之map/">js原生array之map</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80NTYzNS8yMjE0Ng=="><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.benyl.cn"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript-cheerio-xml-markdown/" style="font-size: 15px;">javascript cheerio xml markdown</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/javascript-es6/" style="font-size: 15px;">javascript es6</a> <a href="/tags/javascript-leetcode-算法/" style="font-size: 15px;">javascript leetcode 算法</a> <a href="/tags/javascript-leetcode-链表/" style="font-size: 15px;">javascript leetcode 链表</a> <a href="/tags/javascript-单链表-leetcode/" style="font-size: 15px;">javascript 单链表 leetcode</a> <a href="/tags/javaScript-Array/" style="font-size: 15px;">javaScript Array</a> <a href="/tags/React-性能优化-javascript/" style="font-size: 15px;">React 性能优化 javascript</a> <a href="/tags/javascript-promise/" style="font-size: 15px;">javascript promise</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/01/es6-promise摘/">es6-promise摘</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/26/优化整理01/">优化整理之react14至16</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/反转部分单链表/">反转部分单链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/单链表反转/">单链表反转</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/三数只和/">三数只和</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/两数之和/">两数之和</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/html转markdown/">html转markdown</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/React性能优化技巧学习整理/">react14to16</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/01/js原生array之map/">js原生array之map</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/22/js之map/">js之map</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://shimeng.info/" title="小时哥-erics" target="_blank">小时哥-erics</a><ul></ul><a href="https://www.haomwei.com/" title="屠城-屠夫9411的博客" target="_blank">屠城-屠夫9411的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">玉玲～.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>