<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>es6-promise摘</title>
      <link href="/2019/09/01/es6-promise%E6%91%98/"/>
      <url>/2019/09/01/es6-promise%E6%91%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近看到一篇文章比较好，摘抄下来可以以后学习查看<a href="https://zhuanlan.zhihu.com/p/30797777" target="_blank" rel="noopener">Promise 必知必会（十道题)</a></p></blockquote><a id="more"></a><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="number">2</span>;</span><br><span class="line"><span class="number">3</span>;</span><br><span class="line"><span class="number">4</span>;</span><br></pre></td></tr></table></figure><blockquote><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p></blockquote><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error!!!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>, promise1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>, promise2);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise1 <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line">promise2 <span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line">(node:<span class="number">50928</span>) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="number">1</span>): <span class="built_in">Error</span>: error!!!</span><br><span class="line">(node:<span class="number">50928</span>) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process <span class="keyword">with</span> a non-zero exit code.</span><br><span class="line">promise1 <span class="built_in">Promise</span> &#123; <span class="string">'success'</span> &#125;</span><br><span class="line">promise2 <span class="built_in">Promise</span> &#123;</span><br><span class="line">  &lt;rejected&gt; <span class="built_in">Error</span>: error!!!</span><br><span class="line">    at promise.then (...)</span><br><span class="line">    at &lt;anonymous&gt; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释： Promise 只有三种状态：pending,fulfilled 或 reject.状态改变只能 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变，上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。</p></blockquote><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  reject(<span class="string">"error"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then: "</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch: "</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then: success1;</span><br></pre></td></tr></table></figure><blockquote><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p></blockquote><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;</span><br><span class="line"><span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> javascript promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化整理之react14至16</title>
      <link href="/2019/08/26/%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%8601/"/>
      <url>/2019/08/26/%E4%BC%98%E5%8C%96%E6%95%B4%E7%90%8601/</url>
      
        <content type="html"><![CDATA[<p>总结了一些负责项目升级点</p><a id="more"></a><h3 id="以下总结摘自："><a href="#以下总结摘自：" class="headerlink" title="以下总结摘自："></a>以下总结摘自：</h3><p><strong><a href="https://blog.csdn.net/mapbar_front/article/details/80187123" target="_blank" rel="noopener">React16 版本更新的新特性</a><br><a href="https://blog.csdn.net/Napoleonxxx/article/details/81120854" target="_blank" rel="noopener">React v15 到 v16.3, v16.4 新生命周期总结以及使用场景</a><br><a href="https://blog.csdn.net/u013451157/article/details/78719374" target="_blank" rel="noopener">【ReactJS】V0.14 版本前后的变化</a><br><a href="https://www.jianshu.com/p/a8bc5b292561" target="_blank" rel="noopener">react14 到 15 版本主要变更</a><br><a href="https://blog.csdn.net/xiaozhuo_tang/article/details/88878858" target="_blank" rel="noopener">React15 至今的重要变化人肉梳理</a></strong></p><h3 id="总结如下："><a href="#总结如下：" class="headerlink" title="总结如下："></a>总结如下：</h3><ul><li><h3 id="react-14-到-15"><a href="#react-14-到-15" class="headerlink" title="react 14 到 15"></a><strong>react 14 到 15</strong></h3><ul><li>当在挂载组件时使用 document.createElement 而不是 innerHTML，这样我们就摆脱了 data-reactid。并且 document.createElement 在现代浏览器中也更快；<br><strong>值得注意：</strong> data-reactid 在 client 端已经去除了，但依旧存在在服务端渲染中，不过更小更简 单是简单递增的。</li><li>由于历史原因对 SVG 的不完整支持，在 React 15 中支持了所有被现代浏览器所支持的 SVG 属性；</li><li>社区（Michael Wiencek）的贡献使得 React 15 不再需要多余的对 text 进行包裹；</li><li>渲染 Null 现在使用 comment nodes（注释节点）了；</li><li>函数式组件现在也能返回 null 了；</li><li>移除和弃用<ul><li>移除包括：<br><strong>indDOMNode，render，renderToSring，renderToStaticMarkup 和 unmountComponentAtNode</strong>几个顶级 API，不过他们都能在<strong>ReactDom 和 ReactDomServer</strong>中找到；</li><li>移除的插件： <strong>cloneWithProps 和 batchedUpdates</strong></li><li>移除的组件实例方法：<strong>setProps、replaceProps 和 getDOMNode</strong></li></ul></li></ul></li><li><h3 id="react-15-的一些重大变化"><a href="#react-15-的一些重大变化" class="headerlink" title="react 15 的一些重大变化"></a><strong>react 15 的一些重大变化</strong></h3><ul><li>彻底分离<strong>React 和 React DOM</strong>，现在 React 中将只含有与渲染无关的代码例如：<strong>React.Component 和 React.createElement()</strong></li><li>React DOM Server 包体积大小几乎与 React 相当，因为他有一份自己的 React reconciler。<strong>不建议在 client 端使用 React DOM Server</strong></li><li>拆分了 React.PropTypes 和 React.createClass 到独立的包中；</li><li>React.PropTypes 迁移到了 prop-types 包中,迁移指南；</li><li>React.createClass 迁移到 create-react-class 中，但由于 ES2015 对 class 的支持，React 也开始使用原生的 class 来创建 components；</li><li>data-和 aria-的属性将会任我们自定义</li></ul></li><li><h3 id="react-16-的一些重大变化"><a href="#react-16-的一些重大变化" class="headerlink" title="react 16 的一些重大变化"></a><strong>react 16 的一些重大变化</strong></h3><ul><li>NEW FEATURE：fragments、error boundaries(已经介绍过不做赘述)、portals</li><li>NEW SUPPORT：custom DOM attributes</li><li>IMPROVEMENT：server-side rendering</li><li>render 函数能 return：React elements、Array 和<a href="https://reactjs.org/docs/fragments.html" target="_blank" rel="noopener">fragments</a>、Portals、Booleans or null、String and numbers</li><li><a href="https://reactjs.org/docs/portals.html" target="_blank" rel="noopener">portals</a>是由 React DOM 提供的方法 createPortal(child, container)所创建出来的，能够让元素脱离于 React Tree 在 DOM Tree 的其他地方出现，但事件冒泡依旧是遵循 React DOM tree 的。这个方法可以用来实现 Modal、dialog、tooltips 等。</li><li>更好的服务端渲染：支持流式的传输、三倍快与 React 15 的渲染速度。值得注意的是，React 16 hydrate 工作在 client 端时会使用已经在服务端渲染好的 DOM 结构，而不会做细致检查，只会在 Client 端提示你数据不统一，并且也不建议在 server 端渲染和 client 端 hydrate 时数据不同</li><li>降低了包大小：react 5.3kb(2.2kb gzipped)、react-dom 103.7kb(32.6kb gzipped)</li><li>Breaking changes 摘要：<ul><li>setState(null)不再会引起更新、setState 的 callback 将会在 componentDidMount/componentDidUpdate 后立即执行，而不是在所有 components 渲染后执行</li><li><b>替换<a>时，B 的 componentWillMount 总会发生在 A 的 componentWIllUnmount 之前</a></b></li><li>shallow renderer 不会再出发 componentDidUpdate 因为 DOM refs 是拿不到的，并与 componentDidMount 表现一致</li><li>功能剥离：React.PropTypes =&gt; prop-types、React.Dom =&gt; react-dom-factories、react-addons-test-utils =&gt; react-dom/test-utils、shallow renderer =&gt; react-test-renderer/shallow</li></ul></li><li>React 16 依赖于 Map 和 Set，如果要支持老旧浏览器和设备，应该引入全局的 polyfill，例如 core-js 和 babel-polyfill，同样也依赖于 requestAnimationFrame，可以用 raf 包来弥补</li><li>异步渲染的更新：Two Demos<ul><li>ime slicing、suspense</li></ul></li><li>正式的<a href="https://reactjs.org/docs/context.html" target="_blank" rel="noopener">Context API</a></li><li><a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">createRef API</a>、<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">forwardRef API</a></li><li>生命周期的变更，可参看<a href="https://blog.csdn.net/xiaozhuo_tang/article/details/83824824" target="_blank" rel="noopener">【译】React16.3+ 生命周期</a><ul><li>componentWillMount、componentWillReceiveProps、componentWillUpdate 都不建议在使用并且在 17 中将会被冠上 UNSAFE_的前缀；</li><li>新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate 两个生命周期</li></ul></li><li>React 16.5.0 以上在 React Devtools 新增了一个新功能 Profiler，来帮助我们梳理 React 项目各组件的性能</li><li>React.memo 让 Function 组件用上 PureComponent</li><li>React.lazy 配合 Suspence 和动态引入 import(’’)来优化体验（例如 loading 状态）</li><li>static contextType</li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">hooks</a></li></ul></li></ul><p><strong><a href="https://zh-hans.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">参考学习</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转部分单链表</title>
      <link href="/2019/08/18/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/08/18/%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>javascript实现单链表的部分反转</p><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 ≤ m ≤ n ≤ 链表长度。</p><p><strong>示例:</strong></p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br> 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><p> <strong>解答：</strong><br> 本题有可能存在换头的问题，比如题目的第二个例子，所以函数应该返回调整后的新头节点，整个处理过程如下：<br> 1、先判断是否满足 1 &lt;= from &lt;= to &lt;= N,如果不满足，则直接返回原来的头节点<br> 2、找到第from - 1个节点fPre,和第to + 1个节点 fPos. fPre即是要反转部分的前一个节点。fPos是反转部分的后一个节点。把反转的部分先反转，然后正确地链接fPre和 fPos.<br>  例如：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL，假设fPre为节点1，fPos为节点4，要反转部分为2 -&gt; 3。先反转成3-&gt;2,然后fPre连向即诶单3，节点2连向fPos，就变成了 1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; NULL.<br>3, 如果fPre为NULL,说明反转部分是包含头节点的，则返回新的头节点，也就是没反转之前反转部分的最后一个节点，也是反转之后反转部分的第一个节点。如果fPre不为null，则返回旧的头节点。全部过程代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; m</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseBetween = <span class="function"><span class="keyword">function</span>(<span class="params">head, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = <span class="number">0</span>, node1 = head, fPre = <span class="literal">null</span>, fPos = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (ndoe1 !== <span class="literal">null</span>) &#123;</span><br><span class="line">        fPre = m - <span class="number">1</span> === len ? node1 : fPre;</span><br><span class="line">        fPos = n + <span class="number">1</span> === len ? node1 : fPos;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &gt; n || m &lt; <span class="number">1</span> || n &gt; len) <span class="keyword">return</span> head;</span><br><span class="line">    node1 = fPre == <span class="literal">null</span> ? head : fPre.next;</span><br><span class="line">    <span class="keyword">let</span> node2 = node1.next;</span><br><span class="line">    node1.next = fPos;</span><br><span class="line">    <span class="keyword">let</span> next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node2 !== fPos) &#123;</span><br><span class="line">        next = node2.next;</span><br><span class="line">        node2.next =  node1;</span><br><span class="line">        nod1 = node2;</span><br><span class="line">        node2 = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fPre !== <span class="literal">null</span>) &#123;</span><br><span class="line">        fPre.next = node1;</span><br><span class="line">        <span class="keyword">return</span> headl</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript 单链表 leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表反转</title>
      <link href="/2019/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/08/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>javascript实现单链表的反转</p><a id="more"></a><p>###题目描述<br>反转一个单链表<br><strong>示例</strong></p><blockquote><p>输入 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null<br> 输出 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null</p></blockquote><p> <strong>进阶：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</strong></p><p><strong>思路：</strong><br>循环遍历每个节点:</p><ul><li>记录当前节点的下一个节点</li><li>将当前节点指向当前节点的前一个节点</li><li>当前节点的前一个节点移到当前节点</li><li>当前节点移到当前节点的下一个节点<br>整个函数返回链表的新的头节点<br>如下图所示<br><img src="https://github.com/benyl-nie/hexo-img/blob/master/link/reverse_link.png" alt="单链表反转思路图"></li></ul><p>javascript对单链表的结构构造如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    next = head.next;</span><br><span class="line">    head.next = pre;</span><br><span class="line">    pre = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意： 本来打算用node转数组然后用数组reverse写的，但是在代码中需要返回node格式的数据，所以在执行代码中报错。如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    result.push(head);</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  result = result.reverse();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种怎么说呢，可能思路可以，但是不符合题目要求。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript leetcode 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数只和</title>
      <link href="/2019/08/14/%E4%B8%89%E6%95%B0%E5%8F%AA%E5%92%8C/"/>
      <url>/2019/08/14/%E4%B8%89%E6%95%B0%E5%8F%AA%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript leetcode 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2019/08/14/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/08/14/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript leetcode 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html转markdown</title>
      <link href="/2019/08/14/html%E8%BD%ACmarkdown/"/>
      <url>/2019/08/14/html%E8%BD%ACmarkdown/</url>
      
        <content type="html"><![CDATA[<p>根据路径url和cookie截取指定页面html并将整个页面转成markdown格式输出。<br><a id="more"></a></p><blockquote><p>背景</p></blockquote><p>最近隔壁组有个需求</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript cheerio xml markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react14to16</title>
      <link href="/2019/08/14/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"/>
      <url>/2019/08/14/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>看了最近一篇微信订阅号推送的文章，感觉很不错，摘抄下来方便以后查看，摘自 <a href="https://mp.weixin.qq.com/s/iZqV6GAi5zyX5P48hR4VLA" target="_blank" rel="noopener">你需要掌握的 21 个 React 性能优化技巧</a></p><a id="more"></a><blockquote><p>React 为高性能应用设计提供了许多优化方案，本文列举了其中的一些最佳实践</p></blockquote><p>在以下场景中，父组件和子组件通常会重新渲染：</p><ul><li>在同一组件或父组件中调用 setState 时</li><li>在父级收到的“props”的值发生变化</li><li>调用组件中的 forceUpdate</li></ul><p>下面是提升 React 应用性能的 21 个技巧：</p><h3 id="1、使用纯组件"><a href="#1、使用纯组件" class="headerlink" title="1、使用纯组件"></a>1、使用纯组件</h3><p>如果 React 组件为相同的状态和 props 渲染相同的输出，则可以将 7 其 ️ 是为纯组件。</p><p>对于像 this 的类组件来说，React 提供了 PureComponent 基类。扩展 React.PureComponent 类的类组件被视为纯组件。<br>它与普通组件时一样的，只是 PureComponents 负责 shouldComponentUpdate— 他对状态和 props 数据进行浅层比较（shallow comparision）.</p><p>如果先前的状态和 props 数据与下一个 props 数据或者状态相同，则组件不会重新渲染。</p><ul><li>什么是浅层渲染？<blockquote><p>在对比先前的 props 和状态与下一个 props 和状态时，浅层比较将检查他们的基元是否有相同的值（例如：1 等于 1 或真等于真），还会检查更复杂的 Javascript 值（如对象和数组）之间的引用是否相同</p></blockquote></li></ul><p>比较基元和对象引用的开销比更新组件视图要低。<br>因此，查找状态和 props 值的变化会比不必要的更新更快。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'Mayank'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        name: <span class="string">'Mayank</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;, 1000);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  componentDidMount() &#123;</span></span><br><span class="line"><span class="string">    this.updateState();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Render called Again<span class="string">');</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;RegularChiildComponent name=&#123;this.state.name&#125; /&gt;</span></span><br><span class="line"><span class="string">        &lt;PureChildComponet name=&#123;this.state.name&#125; /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class RegularChildComponent extends React.Component &#123;</span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Regular Compoment Rendered..<span class="string">');</span></span><br><span class="line"><span class="string">    return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class PureChildComponent extends React.PureComponent &#123;</span></span><br><span class="line"><span class="string">  // Pure Component are the component that do not re-render if the state data or props data is still the same</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    console.log('</span>Pure Component are Rendered...<span class="string">');</span></span><br><span class="line"><span class="string">    return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，状态被传播到自组件 RegularChildComponent 和 PureChildComponent。PureChildComponent 是一个纯组件。</p><p>setState 在一秒的间隔之后被调用，这将重新触发组件的视图渲染。由于初始 props 和新 props 的值相同，因此组件(PureChildComponent) 不会被重新渲染<br>状态的浅层比较表明 props 或状态的数据没有变化，因此不需要渲染数据，从而提高了性能</p><h3 id="2、使用-React-memo-进行组件记忆"><a href="#2、使用-React-memo-进行组件记忆" class="headerlink" title="2、使用 React.memo 进行组件记忆"></a>2、使用 React.memo 进行组件记忆</h3><p>React.memo 是一个高阶组件。</p><p>它很像 PureComponent,但 PureComponent 属于 Component 的类实现，而‘memo’则用于创建函数组件。</p><p>这里与纯组件类似，如果输入 props 相同则跳过组件渲染，从而提升组件性能。</p><p>它会记忆上次某个输入 props 的执行输出并提升应用性能。即使在这些组件中比较也是浅层的。</p><p>你还可以为这个组件传递自定义比较逻辑。</p><p>用户可以用自定义逻辑深度对比(deep comparision)对象。如果比较函数返回 false 则重新渲染组件，否则就不会重新渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomisedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;User name: &#123;props.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;b&gt;User age: &#123;props.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;b&gt;User designation: &#123;props.designation&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the compoment below is rhe optimised version for the Default component</span></span><br><span class="line"><span class="comment">// The Component will not re-render if same props value for 'name' property</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memoComponet = React.mmeo(CustomisedComponent);</span><br></pre></td></tr></table></figure><p>上面的组件将对前后两个 props 的值进行浅层比较<br>如果我们将对象引用作为 props 传递给 memo 组件，则需要一些自定义登陆以进行比较。在这种情况下，我们可以将比较函数作为第二个参数传递给 React.memo 函数<br>假设 props 值（user）是一个对象引用，包含特定用户的 name，age 和 designation。<br>这种情况下需要进行深入比较，我们可以创建一个自定义函数，查找前后两个 props 值的 name,age 和 designation 的值，如果它们不相同则返回 false<br>这样，即使我们将参考数据作为 memo 组件的输入，组件也不会重新渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following function takes 'user' Object as input parameter in props</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CustomisedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;b&gt;User name: &#123;props.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;b&gt;User age: &#123;props.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;b&gt;User designation: &#123;props.designation&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">userComparator</span>(<span class="params">previonProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    previonProps.user.name == nextProps.user.name ||</span><br><span class="line">    previonProps.user.age == nextProps.user.age ||</span><br><span class="line">    previonProps.user.designation == nextProps.user.designation</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memoComponent = React.memo(CustomisedComponent, userComparator);</span><br></pre></td></tr></table></figure><p>上面的代码提供了用于比较的自定义逻辑</p><h3 id="3、使用-shouldComponentUpdate-生命周期函数"><a href="#3、使用-shouldComponentUpdate-生命周期函数" class="headerlink" title="3、使用 shouldComponentUpdate 生命周期函数"></a>3、使用 shouldComponentUpdate 生命周期函数</h3><blockquote><p>这是在重新渲染组件之前触发的其中一个生命周期事件</p></blockquote><p>可以利用此事件来决定何时需要重新渲染组件，如果组件 props 更改或调用 setState,则此函数返回一个 Boolean 值。<br>在这两种情况下组件都会重新渲染。我们可以在这个生命周期事件中放置一个自定义逻辑，以决定是否调用组件的 render 函数</p><p>这个函数将 nextState 和 nextProps 作为输入，并可将其与当前 props 和状态做对比，以决定是否需要重新渲染。<br>比如说我想再网页上显示员工的详细资料。每位员工都包含多个属性，如姓名，年龄，牌号，薪水，当前经理，前任经理，奖金等。</p><p>我想只在网页上渲染员工的姓名和年龄。员工的牌号会在某时刻更新。</p><p>由于员工牌号不在视图内，理想情况下视图是无需要更新的，我们可以在组件中添加自定义逻辑，哦安段是否需要组件更新视图</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ShouldComponentUpdateState</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'Mayank'</span>,</span><br><span class="line">      age: <span class="number">30</span>,</span><br><span class="line">      designation: <span class="string">'Architect</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  ComponentDidMount() &#123;</span></span><br><span class="line"><span class="string">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="string">      this.setState(&#123;</span></span><br><span class="line"><span class="string">        designation: '</span>hhhhhhh<span class="string">'</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  shouleComponentUpdate(nextProps, nextState) &#123;</span></span><br><span class="line"><span class="string">    if (nextState.age != this.state.age || nextState.name != this.state.name) return true;</span></span><br><span class="line"><span class="string">    return false;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  render() &#123;</span></span><br><span class="line"><span class="string">    return (</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">         &lt;b&gt;User name: &#123;props.name&#125;&lt;/b&gt;</span></span><br><span class="line"><span class="string">        &lt;b&gt;User age: &#123;props.age&#125;&lt;/b&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这里即使组件中 designation 发生变化也不会影响应用的视图。</p><p>调用 setState 时组件会重新渲染，但因为 designation 更改不会改变/影响组件的视图，因此在更改 designation 时重新渲染组件会带来额外开销。</p><p>为了避免这种开销。我们可以使用自定义逻辑检查 name 或 age 是否更新，因为视图仅受他们的影响</p><p>shouleComponentUpdate 将输入参数作为状态和 props 的新值</p><p>我们可以比较 name 和 age 的当前值和新值，有任何一个发生变化就可以触发重新渲染。</p><p>从 shouleComponentUpdate 传递 true 就意味着可以重新渲染组件，反之亦然。所以正确使用 shouleComponentUpdate 就可以优化应用组件的性能。</p><p>对比初始状态和 props 后我们就可以决定祖耀重新渲染组件。这样就可以减少重新渲染的需求来提升性能。</p><h3 id="4-懒加载组件"><a href="#4-懒加载组件" class="headerlink" title="4. 懒加载组件"></a>4. 懒加载组件</h3><p>导入多个文件合并到一个文件中的过程叫打包，使应用不必导入大量外部文件。</p><p>所有主要组件和外部依赖项都合并为一个文件，通过网络传送出去以启动并运行 Web 应用。</p><p>这样可以节省大量网络调用，但这个文件会变得很大，消耗大量网络带宽。</p><p>应用需要等待这个文件的加载和执行，所以传输延迟会带来严重的影响。</p><p>为了解决这个问题，我们引入代码拆分的概念。</p><p>像 webpack 这样的打包器支持就支持代码拆分，它可以为应用创建多个包，并在运行时动态加载，减少初始包的大小。</p><p>为此我们使用 Suspense 和 lazy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CallingLazyComponents</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> ComponentToLazyLoad = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.name == <span class="string">"Mayank"</span>) &#123;</span><br><span class="line">      ComponentToLazyLoad = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./mayankComponent"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.props.name == <span class="string">"Anshul"</span>) &#123;</span><br><span class="line">      ComponentToLazyLoad = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./anshulComponent"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;This is the Base User: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/</span>div&gt;&#125;&gt;</span><br><span class="line">          &lt;ComponentToLazyLoad /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有一个条件语句，它查找 props 值，并根据指定的条件加载主组件中的两个组件。</p><p>我们可以按需懒惰加载这些拆分出来的组件，增强应用的整体性能。</p><p>假设有两个组件 WelcomeComponent 或 GuestComponents，我们根据用户是否登录而渲染其中一个。</p><p>我们可以根据具体的条件延迟组件加载，无需一开始就加载两个组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSalutation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.username !== <span class="string">""</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> WelcomeComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./welcomeComponent"</span>));</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;WelcomeComponent /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> GuestComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./guestComponent"</span>));</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;GuestComponent /</span>&gt;</span><br><span class="line">          &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们没有预加载 WelcomeCompoment 和 GuestComponents 这两个组件，而是进行一个条件检查。</p><p>如果用户名存在（或相反），我们就根据指定的条件决定将某个组件作为单独的包加载。</p><ul><li>这个方法的好处<blockquote><p>1、主包体积变小，消耗的网络传输时间更少。<br>2、动态单独加载的包比较小，可以迅速加载完成。</p></blockquote></li></ul><p>我们可以分析应用来决定懒加载哪些组件，从而减少应用的初始加载时间。</p><h3 id="5-使用-React-Fragments-避免额外标记"><a href="#5-使用-React-Fragments-避免额外标记" class="headerlink" title="5. 使用 React Fragments 避免额外标记"></a>5. 使用 React Fragments 避免额外标记</h3><p>使用 Fragments 减少了包含的额外标记数量，这些标记只是为了满足在 React 组件中具有公共父级的要求。</p><p>用户创建新组件时，每个组件应具有单个父标签。父级不能有两个标签，所以顶部要有一个公共标签。所以我们经常在组件顶部添加额外标签，例如：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSNLsyKLGfsAGibof63PPoMe7dHCicaMjtUyM7IficHJianqDaROTJg0zUQ9A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="举例图片"></p><p>在上面指定的组件中，我们需要一个额外的标签为要渲染的组件提供公共父级。</p><p>除了充当组件的父标签之外，这个额外的 div 没有其他用途。</p><p>在顶层有多个标签会导致以下错误：<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSNwXEYVZC2ibgpw4ibfBWQxtRNaoBYDsn7JuySLDBETXaDKwXQsYQAficHw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="举例图片2"><br>要解决此问题，我们可以将元素包含在片段（fragement）中。</p><p>片段不会向组件引入任何额外标记，但它仍然为两个相邻标记提供父级，因此满足在组件顶级具有单个父级的条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedRoutingComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;This is the Header Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;Welcome To Demo Page&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的代码没有额外的标记，因此节省了渲染器渲染额外元素的工作量。</p><p>详细信息参考:<br><a href="https://github.com/facebook/react/issues/2127" target="_blank" rel="noopener">https://github.com/facebook/react/issues/2127</a></p><h3 id="6-不要使用内联函数定义"><a href="#6-不要使用内联函数定义" class="headerlink" title="6. 不要使用内联函数定义"></a>6. 不要使用内联函数定义</h3><p>如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例。</p><p>当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。</p><p>因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineFunctionComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="button"</span></span><br><span class="line"><span class="regexp">          onClick=&#123;e =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123; inputValue: e.target.value &#125;);</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">          value="Click For Inline Function"</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面的函数创建了内联函数。每次调用 render 函数时都会创建一个函数的新实例，render 函数会将该函数的新实例绑定到该按钮。</p><p>此外最后一个函数实例会被垃圾回收，大大增加了 React 应用的工作量。</p><p>所以不要用内联函数，而是在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 render 时就不会创建单独的函数实例了，参考组件如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineFunctionComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  setNewStateData = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Welcome Guest&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type="button"</span></span><br><span class="line"><span class="regexp">          onClick=&#123;this.setNewStateData&#125;</span></span><br><span class="line"><span class="regexp">          value="Click For Inline Function"</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7-避免-componentWillMount-中的异步请求"><a href="#7-避免-componentWillMount-中的异步请求" class="headerlink" title="7. 避免 componentWillMount()中的异步请求"></a>7. 避免 componentWillMount()中的异步请求</h3><p>componentWillMount 是在渲染组件之前调用的。</p><p>这个函数用的不多，可用来配置组件的初始配置，但使用 constructor 方法自己也能做到。</p><p>该方法无法访问 DOM 元素，因为组件还没挂载上来。</p><p>一些开发人员认为这个函数可以用来做异步数据 API 调用，但其实这没什么好处。</p><p>由于 API 调用是异步的，因此组件在调用 render 函数之前不会等待 API 返回数据。于是在初始渲染中渲染组件时没有任何数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingAsyncInComponentWillMount</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      userData: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    axios.get(<span class="string">"someResourceUrl"</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        userData: data</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b&gt;UserName: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;UserAge: &#123;this.state.age&#125;&lt;/</span>b&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们正在进行异步调用以获取数据。由于数据调用是异步的，需要一段时间才能获取到。</p><p>在检索数据时 React 会触发组件的 render 函数。因此第一个调用的渲染仍然不包含它所需的数据。</p><p>这样一开始渲染组件没有数据，然后检索数据，调用 setState，还得重新渲染组件。在 componentWillMount 阶段进行 AJAX 调用没有好处可言。</p><p>我们应避免在此函数中发出 Async 请求。这些函数和调用可以延迟到 componentDidMount 生命周期事件里。</p><p><strong>注意</strong>：React 16.3 不推荐使用 componentWillMount。如果你使用的是最新版本的 React，请避免使用这个生命周期事件。</p><h3 id="8-在-Constructor-的早期绑定函数"><a href="#8-在-Constructor-的早期绑定函数" class="headerlink" title="8. 在 Constructor 的早期绑定函数"></a>8. 在 Constructor 的早期绑定函数</h3><p>当我们在 React 中创建函数时，我们需要使用 bind 关键字将函数绑定到当前上下文。</p><p>绑定可以在构造函数中完成，也可以在我们将函数绑定到 DOM 元素的位置上完成。</p><p>两者之间似乎没有太大差异，但性能表现是不一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          value=<span class="string">"Click"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们在 render 函数的绑定期间将函数绑定到按钮上。</p><p>上面代码的问题在于，每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.handleButtonClick = <span class="keyword">this</span>.handleButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click"</span> onClick=&#123;<span class="keyword">this</span>.handleButtonClick&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>最好在构造函数调用期间使用绑定到当前上下文的函数覆盖 handleButtonClick 函数。</p><p>这将减少将函数绑定到当前上下文的开销，无需在每次渲染时重新创建函数，从而提高应用的性能。</p><h3 id="9-箭头函数与构造函数中的绑定"><a href="#9-箭头函数与构造函数中的绑定" class="headerlink" title="9. 箭头函数与构造函数中的绑定"></a>9. 箭头函数与构造函数中的绑定</h3><p>处理类时的标准做法就是使用箭头函数。使用箭头函数时会保留执行的上下文。</p><p>我们调用它时不需要将函数绑定到上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedBinding</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">"Button Clicked: "</span> + <span class="keyword">this</span>.state.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click"</span> onClick=&#123;<span class="keyword">this</span>.handleButtonClick&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>箭头函数好处多多，但也有缺点。</p><blockquote><p>当我们添加箭头函数时，该函数被添加为对象实例，而不是类的原型属性。这意味着如果我们多次复用组件，那么在组件外创建的每个对象中都会有这些函数的多个实例。<br>每个组件都会有这些函数的一份实例，影响了可复用性。此外因为它是对象属性而不是原型属性，所以这些函数在继承链中不可用。</p></blockquote><p>因此箭头函数确实有其缺点。实现这些函数的最佳方法是在构造函数中绑定函数，如上所述。</p><h3 id="10-避免使用内联样式属性"><a href="#10-避免使用内联样式属性" class="headerlink" title="10. 避免使用内联样式属性"></a>10. 避免使用内联样式属性</h3><p>使用内联样式时浏览器需要花费更多时间来处理脚本和渲染，因为它必须映射传递给实际 CSS 属性的所有样式规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">InlineStyledComponents</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b style=&#123;&#123; <span class="attr">backgroundColor</span>: <span class="string">"blue"</span> &#125;&#125;&gt;Welcome to Sample Page&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面创建的组件中，我们将内联样式附加到组件。添加的内联样式是 JavaScript 对象而不是样式标记。</p><p>样式 backgroundColor 需要转换为等效的 CSS 样式属性，然后才应用样式。这样就需要额外的脚本处理和 JS 执行工作。</p><p>更好的办法是将 CSS 文件导入组件。</p><h3 id="11-优化-React-中的条件渲染"><a href="#11-优化-React-中的条件渲染" class="headerlink" title="11. 优化 React 中的条件渲染"></a>11. 优化 React 中的条件渲染</h3><p>安装和卸载 React 组件是昂贵的操作。为了提升性能，我们需要减少安装和卸载的操作。</p><p>很多情况下在我们可能会渲染或不渲染特定元素，这时可以用条件渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AdminHeaderComponent <span class="keyword">from</span> <span class="string">"./AdminHeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> HeaderComponent <span class="keyword">from</span> <span class="string">"./HeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> ContentComponent <span class="keyword">from</span> <span class="string">"./ContentComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRendering</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.name == <span class="string">"Mayank"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">          &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt;</span><br><span class="line">          &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125; else &#123;</span></span><br><span class="line"><span class="regexp">      return (</span></span><br><span class="line"><span class="regexp">        &lt;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;HeaderComponent&gt;&lt;/</span>HeaderComponent&gt;</span><br><span class="line">          &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中有一个条件语句，让组件根据指定的条件渲染。如果状态包含名称值 Mayank，则不会渲染 AdminHeaderComponent。</p><p>条件运算符和 if else 条件似乎没问题，但后面的代码有性能问题，需要分析一下。</p><p>每次调用 render 函数，并且值在 Mayank 和另一个值之间切换时，都会执行不同的 if else 语句。</p><p>diffing 算法会运行一个检查，比较每个位置的元素类型。在 diffing 期间，它看到 AdminHeaderComponent 不可用，并且需要渲染的第一个组件是 HeaderComponent。</p><p>React 将观察元素的位置。它看到位置 1 和位置 2 的组件已更改并将卸载组件。</p><p>组件 HeaderComponent 和 ContentComponent 将在位置 1 和位置 2 卸载并重新安装。其实这是用不着的，因为这些组件没有更改，这是一项昂贵的操作。优化方案如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AdminHeaderComponent <span class="keyword">from</span> <span class="string">"./AdminHeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> HeaderComponent <span class="keyword">from</span> <span class="string">"./HeaderComponent"</span>;</span><br><span class="line"><span class="keyword">import</span> ContentComponent <span class="keyword">from</span> <span class="string">"./ContentComponent"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalRendering</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.name == <span class="string">"Mayank"</span> &amp;&amp; (</span><br><span class="line">          &lt;AdminHeaderComponent&gt;&lt;/AdminHeaderComponent&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;</span><br><span class="line">        &lt;ContentComponent&gt;&lt;/ContentComponent&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，当 name 不是 Mayank 时，React 在位置 1 处放置 null。</p><p>开始 DOM diffing 时，位置 1 的元素从 AdminHeaderComponent 变为 null，但位置 2 和位置 3 的组件保持不变。</p><p>由于元素没变，因此组件不会卸载，减少了不必要的操作。</p><p>详细信息请参阅:<br><a href="https://medium.com/@cowi4030/optimizing-conditional-rendering-in-react-3fee6b197a20" target="_blank" rel="noopener">https://medium.com/@cowi4030/optimizing-conditional-rendering-in-react-3fee6b197a20</a></p><h3 id="12-不要在-render-方法中导出数据"><a href="#12-不要在-render-方法中导出数据" class="headerlink" title="12. 不要在 render 方法中导出数据"></a>12. 不要在 render 方法中导出数据</h3><p>Render 方法是 React 开发人员最熟悉的生命周期事件。</p><p>和其他生命周期事件不一样的是，我们的核心原则是将 render() 函数作为纯函数。</p><ul><li>纯函数对 render 方法意味着什么？<blockquote><p>纯函数意味着我们应该确保 setState 和查询原生 DOM 元素等任何可以修改应用状态的东西不会被调用。<br>该函数永远不该更新应用的状态。<br>更新组件状态的问题在于，当状态更新时会触发另一个 render 循环，后者在内部会再触发一个 render 循环，以此类推。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderFunctionOptimization</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">"Mayank"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      name: <span class="keyword">this</span>.state.name + <span class="string">"_"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;b&gt;User Name: &#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，每次调用 render 函数时都会更新状态。状态更新后组件将立即重新渲染。因此更新状态会导致 render 函数的递归调用。</p><p>render 函数应保持纯净，以确保组件以一致的方式运行和渲染。</p><h3 id="13-为组件创建错误边界"><a href="#13-为组件创建错误边界" class="headerlink" title="13. 为组件创建错误边界"></a>13. 为组件创建错误边界</h3><p>组件渲染错误是很常见的情况。</p><p>在这种情况下，组件错误不应该破坏整个应用。创建错误边界可避免应用在特定组件发生错误时中断。</p><p>错误边界是一个 React 组件，可以捕获子组件中的 JavaScript 错误。我们可以包含错误、记录错误消息，并为 UI 组件故障提供回退机制。</p><p>错误边界是基于高阶组件的概念。</p><p>详细信息参阅:<br><a href="https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634" target="_blank" rel="noopener">https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634</a></p><p>错误边界涉及一个高阶组件，包含以下方法：static getDerivedStateFromError() 和 componentDidCatch()。</p><p>static 函数用于指定回退机制，并从收到的错误中获取组件的新状态。</p><p>componentDidCatch 函数用来将错误信息记录到应用中。</p><p>下面是代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundaries</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      hasErrors: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">"Component Did Catch Error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="string">"Get Derived State From Error"</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      hasErrors: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasErrors === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;div&gt;This is a Error&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ShowData name=<span class="string">"Mayank"</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export class ShowData extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor() &#123;</span></span><br><span class="line"><span class="regexp">    super();</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      name: "Mayank"</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  changeData = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;</span></span><br><span class="line"><span class="regexp">      name: "Anshul"</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    if (this.state.name === "Anshul") &#123;</span></span><br><span class="line"><span class="regexp">      throw new Error("Sample Error");</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;b&gt;This is the Child Component &#123;this.state.name&#125;&lt;/</span>b&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">"button"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.changeData&#125;</span><br><span class="line">          value=<span class="string">"Click To Throw Error"</span></span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当 name 更新为 Anshul 时，上面的代码会抛出错误。</p><p>组件 ShowData 是 ErrorBoundaries 组件内的嵌入。</p><p>因此，如果错误是从 ShowData 函数内抛出的，则它会被父组件捕获，我们使用 static getDerivedStateFromError 函数和 componentDidCatch 生命周期事件中的日志数据部署回退 UI。</p><h3 id="14-组件的不可变数据结构"><a href="#14-组件的不可变数据结构" class="headerlink" title="14. 组件的不可变数据结构"></a>14. 组件的不可变数据结构</h3><p>React 的灵魂是函数式编程。如果我们希望组件能一致工作，则 React 组件中的状态和 props 数据应该是不可变的。</p><p>对象的突变可能导致输出不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line">expoort <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableComponentData</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        name: <span class="string">"Mayank"</span>,</span><br><span class="line">        age: <span class="number">30</span>,</span><br><span class="line">        designation: <span class="string">"Software Architect"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateUser() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      userInfo: &#123;</span><br><span class="line">        name: <span class="string">"OtherUser"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nextState.userInfo != <span class="keyword">this</span>.state.userInfo) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;b&gt;User Name: &#123;<span class="keyword">this</span>.state.userName&#125;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如上所示。在 shouldComponentUpdate 函数中我们指定，如果 userInfo 的初始值与 userInfo 的新值不同，则应该重新渲染该组件；反之不应重新渲染组件。</p><p>详细信息参阅:<br><a href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc" target="_blank" rel="noopener">https://blog.logrocket.com/immutability-in-react-ebe55253a1cc</a></p><h3 id="15-使用唯一键迭代"><a href="#15-使用唯一键迭代" class="headerlink" title="15. 使用唯一键迭代"></a>15. 使用唯一键迭代</h3><p>当我们需要渲染项目列表时应该为项目添加一个键。</p><p>键可以用来识别已更改、添加或删除的项目。键为元素提供了稳定的标识。一个键应该对应列表中的唯一一个元素。</p><p>如果开发人员没有为元素提供键，则它将 index 作为默认键。在下面的代码中我们默认不添加任何键，因此 index 将用作列表的默认键。</p><p>使用 index 作为键就不会出现标识不唯一的问题了，因为 index 只会标识所渲染的组件。</p><blockquote><p>我们可以在以下场景中使用 index 作为键：</p></blockquote><ul><li>列表项是静态的，项目不随时间变化。</li><li>Items 没有唯一 ID。</li><li>List 永远不会重新排序或过滤。</li><li>不会从顶部或中间添加或删除项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">export default class ComponentRecreation extends React.Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            inputName: &quot;&quot;,</span><br><span class="line">            arrayData: [&quot;Mayank&quot;, &quot;Meha&quot;, &quot;Anshul&quot;, &quot;Arjun&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateUserName(event) &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            inputName: event.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addUserData() &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            arrayData: [this.state.inputName, ...this.state.arrayData]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        var dataList = this.state.arrayData.map((data, index) =&gt; &#123;</span><br><span class="line">            return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;</span><br><span class="line">        &#125;)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; value=&#123;this.state.inputName&#125; placeholder=&quot;Enter Unique Name&quot; onChange=&#123;this.updateUserName.bind(this)&#125; /&gt;</span><br><span class="line">                &lt;input type=&quot;button&quot; onClick=&#123;this.addUserData.bind(this)&#125; value=&quot;Click To Add&quot; /&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">                &lt;b&gt;List of Users: &lt;/b&gt;&lt;br&gt;&lt;/br&gt;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">                &#123;dataList&#125;&lt;br&gt;&lt;/br&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在列表中添加项目<br>使用 index 作为键会加大错误率并降低应用的性能。</p></blockquote><p>每当新元素添加到列表时，默认情况下 React 会同时遍历新创建的列表和旧列表，并在需要时进行突变。</p><p>在列表顶部添加一个新元素（包含 index 作为键）时，全部已有组件的索引都会更新。</p><p>索引更新后，之前键值为 1 的元素现在的键值变成了 2。更新所有组件会拖累性能。</p><p>上面的代码允许用户在列表顶部添加新项目。但在顶部插入元素后果最严重。因为顶部元素一变，后面所有的元素都得跟着改键值，从而导致性能下降。</p><p>因此，我们应该确保键值和元素一一对应不会变化。</p><ul><li><p>Key 不仅影响性能，更重要的作用是标识。随机分配和更改的值不算是标识。</p></li><li><p>我们得知道数据的建模方式才能提供合适的键值。如果你没有 ID，我建议使用某种哈希函数生成 ID。</p></li><li><p>我们在使用数组时已经有了内部键，但它们是数组中的索引。插入新元素时这些键是错误的</p></li></ul><p>详细信息请参阅：</p><ul><li><p><a href="https://reactjs.org/docs/reconciliation.html?#recursing-on-children" target="_blank" rel="noopener">https://reactjs.org/docs/reconciliation.html?#recursing-on-children</a></p></li><li><p><a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank" rel="noopener">https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318</a></p></li></ul><h3 id="16-事件节流和防抖"><a href="#16-事件节流和防抖" class="headerlink" title="16. 事件节流和防抖"></a>16. 事件节流和防抖</h3><p>节流（throttling）和防抖（debouncing）可用来限制在指定时间内调用的事件处理程序的数量。</p><p>事件处理程序是响应不同事件（如鼠标单击和页面滚动）而调用的函数。事件触发事件处理程序的速率是不一样的。</p><p><strong>节流的概念</strong></p><blockquote><p>节流意味着延迟函数执行。<br>这些函数不会立即执行，在触发事件之前会加上几毫秒延迟。<br>比如在页面滚动时，我们不会过于频繁地触发滚动事件，而是将事件延迟一段时间以便将多个事件堆叠在一起。<br>它确保函数在特定时间段内至少调用一次。如果函数最近运行过了，它将阻止函数运行，确保函数以固定间隔定期运行。<br>当我们处理无限滚动并且当用户接近页面底部必须获取数据时，我们可以使用节流。<br>否则滚动到页面底部将触发多个事件，并且触发对网络的多次调用，从而导致性能问题。</p></blockquote><p><strong>防抖的概念</strong></p><blockquote><p>防抖是指在调用停止一段时间之前忽略事件处理程序调用。<br>假设我们有一个事件，有一秒钟的 debounce 时间。一旦用户停止触发事件，该事件的事件处理程序将在一秒钟后触发</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkVq7r2MICNGrSmLzFDicvKSN9L65kcvyr2sAH200o44aMSWnBbyb8IaV20sQ0dfyGkLOkOGG4YTrIA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="用例图"></p><blockquote><p>典型的例子是用户在自动填充搜索框中键入数据。<br>一旦用户停止键入，就会进行 AJAX 查询以从 API 获取数据。每次键入都进行 AJAX 调用就需要多次查询数据库。<br>因此，我们对该事件做 debounce，直到用户不再输入数据为止，从而减少网络调用并提升性能。<br>我们可以使用第三方库来实现和使用节流和防抖功能，例如 throttle-debounce。具体用法参阅:<br><a href="https://www.npmjs.com/package/throttle-debounce。" target="_blank" rel="noopener">https://www.npmjs.com/package/throttle-debounce。</a></p></blockquote><h3 id="17-使用-CDN"><a href="#17-使用-CDN" class="headerlink" title="17. 使用 CDN"></a>17. 使用 CDN</h3><p>谷歌、亚马逊和微软等公司提供了许多内容分发网络。</p><p>这些 CDN 是可在你的应用中使用的外部资源。我们甚至可以创建私有 CDN 并托管我们的文件和资源。</p><p>使用 CDN 有以下好处：</p><ul><li><strong>不同的域名。</strong> 浏览器限制了单个域名的并发连接数量，具体取决于浏览器设置。假设允许的并发连接数为 10。如果要从单个域名中检索 11 个资源，那么同时完成的只有 10 个，还有 1 个需要再等一会儿。CDN 托管在不同的域名 / 服务器上。因此资源文件可以分布在不同的域名中，提升了并发能力。</li><li><strong>文件可能已被缓存。</strong> 有很多网站使用这些 CDN，因此你尝试访问的资源很可能已在浏览器中缓存好了。这时应用将访问文件的已缓存版本，从而减少脚本和文件执行的网络调用和延迟，提升应用性能。</li><li><strong>高容量基础设施。</strong> 这些 CDN 由大公司托管，因此可用的基础设施非常庞大。他们的数据中心遍布全球。向 CDN 发出请求时，它们将通过最近的数据中心提供服务，从而减少延迟。这些公司会对服务器做负载平衡，以确保请求到达最近的服务器并减少网络延迟，提升应用性能。</li></ul><p>如果担心安全性，可以使用私有 CDN。</p><h3 id="18-用-CSS-动画代替-JavaScript-动画"><a href="#18-用-CSS-动画代替-JavaScript-动画" class="headerlink" title="18. 用 CSS 动画代替 JavaScript 动画"></a>18. 用 CSS 动画代替 JavaScript 动画</h3><p>在 HTML 5 和 CSS 3 出现之前，动画曾经是 JavaScript 的专属，但随着 HTML 5 和 CSS 3 的引入情况开始变化。现在动画甚至可以由 CSS 3 来处理了。</p><blockquote><p>我们可以制定一些规则：</p></blockquote><ul><li>如果 CSS 可以实现某些 JS 功能，那就用 CSS。</li><li>如果 HTML 可以实现某些 JS 功能，那就用 HTML。</li></ul><blockquote><p>理由如下：</p></blockquote><ul><li>破损的 CSS 规则和样式不会导致网页损坏，而 JavaScript 则不然。</li><li>解析 CSS 是非常便宜的，因为它是声明性的。我们可以为样式并行创建内存中的表达，可以推迟样式属性的计算，直到元素绘制完成。</li><li>为动画加载 JavaScript 库的成本相对较高，消耗更多网络带宽和计算时间。</li><li>虽然 JavaScript 可以提供比 CSS 更多的优化，但优化过的 JavaScript 代码也可能卡住 UI 并导致 Web 浏览器崩溃。</li></ul><p>详细信息参阅:<br><a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript</a></p><h3 id="19-在-Web-服务器上启用-gzip-压缩"><a href="#19-在-Web-服务器上启用-gzip-压缩" class="headerlink" title="19. 在 Web 服务器上启用 gzip 压缩"></a>19. 在 Web 服务器上启用 gzip 压缩</h3><p>压缩是节省网络带宽和加速应用的最简单方法。</p><p>我们可以把网络资源压缩到更小的尺寸。Gzip 是一种能够快速压缩和解压缩文件的数据压缩算法。</p><p>它可以压缩几乎所有类型的文件，例如图像、文本、JavaScript 文件、样式文件等。Gzip 减少了网页需要传输到客户端的数据量。</p><p>当 Web 服务器收到请求时，它会提取文件数据并查找 Accept-Encoding 标头以确定如何压缩应用。</p><p>如果服务器支持 gzip 压缩，资源会被压缩后通过网络发送。每份资源的压缩副本（添加了 Content-Encoding 标头）指定使用 gzip 解压。</p><p>然后，浏览器将内容解压缩原始版本在渲染给用户。</p><p>只是 gzip 压缩需要付出成本，因为压缩和解压缩文件属于 CPU 密集型任务。但我们还是建议对网页使用 gzip 压缩。</p><p>详细信息参阅:<br><a href="https://royal.pingdom.com/can-gzip-compression-really-improve-web-performance" target="_blank" rel="noopener">https://royal.pingdom.com/can-gzip-compression-really-improve-web-performance</a></p><h3 id="20-使用-Web-Workers-处理-CPU-密集任务"><a href="#20-使用-Web-Workers-处理-CPU-密集任务" class="headerlink" title="20. 使用 Web Workers 处理 CPU 密集任务"></a>20. 使用 Web Workers 处理 CPU 密集任务</h3><p>JavaScript 是一个单线程应用，但在渲染网页时需要执行多个任务：</p><p>处理 UI 交互、处理响应数据、操纵 DOM 元素、启用动画等。所有这些任务都由单个线程处理。</p><p>可以使用 worker 来分担主线程的负载。</p><p>Worker 线程在后台运行，可以在不中断主线程的情况下执行多个脚本和 JavaScript 任务。</p><p>每当需要执行长时间的 CPU 密集任务时，可以使用 worker 在单独的线程上执行这些逻辑块。</p><p>它们在隔离环境中执行，并且使用进程间线程通信与主线程交互。主线程就可以腾出手来处理渲染和 DOM 操作任务。</p><p>详细信息参阅:<br><a href="https://medium.com/prolanceer/optimizing-react-app-performance-using-web-workers-79266afd4a7" target="_blank" rel="noopener">https://medium.com/prolanceer/optimizing-react-app-performance-using-web-workers-79266afd4a7</a></p><h3 id="21-React-组件的服务端渲染"><a href="#21-React-组件的服务端渲染" class="headerlink" title="21. React 组件的服务端渲染"></a>21. React 组件的服务端渲染</h3><p>服务端渲染可以减少初始页面加载延迟。</p><p>我们可以让网页从服务端加载初始页面，而不是在客户端上渲染。这样对 SEO 非常有利。</p><p>服务端渲染是指第一个组件显示的内容是从服务器本身发送的，而不是在浏览器级别操作。之后的页面直接从客户端加载。</p><p>这样我们就能把初始内容放在服务端渲染，客户端只按需加载部分页面。</p><blockquote><p>其好处包括：</p></blockquote><ul><li>性能：初始页面内容和数据是从服务器本身加载的，因此我们不需要添加加载器和下拉列表，而是等待初始页面加载完毕后再加载初始组件。</li><li>SEO 优化：爬虫在应用初始加载时查找页面内容。在客户端渲染时初始 Web 页面不包含所需的组件，这些组件需要等 React 脚本等文件加载完毕后才渲染出来</li></ul><p>服务端渲染还可以使用第三方库，如 Next.js。详细信息参阅: <a href="https://nextjs.org/" target="_blank" rel="noopener">https://nextjs.org/</a></p><p>这里有服务端渲染的示例项目：<a href="https://github.com/Mayankgupta688/reactServerRendering。只需从项目存储库执行以下步骤即可运行应用" target="_blank" rel="noopener">https://github.com/Mayankgupta688/reactServerRendering。只需从项目存储库执行以下步骤即可运行应用</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>这个应用中“pages”文件夹里的文件是可以用服务端渲染加载的初始 URL</p><blockquote><p>参考</p></blockquote><ul><li>示例代码 GitHub 仓库: <a href="https://github.com/Mayankgupta688/react-demos" target="_blank" rel="noopener">https://github.com/Mayankgupta688/react-demos</a></li><li>英文原文:<a href="https://medium.com/better-programming/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349" target="_blank" rel="noopener">https://medium.com/better-programming/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React 性能优化 javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原生array之map</title>
      <link href="/2019/07/01/js%E5%8E%9F%E7%94%9Farray%E4%B9%8Bmap/"/>
      <url>/2019/07/01/js%E5%8E%9F%E7%94%9Farray%E4%B9%8Bmap/</url>
      
        <content type="html"><![CDATA[<p>最近看mdn中 Array.prototype.map，以下为看的总结点</p><a id="more"></a><h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> map()方法创建一个新数组，其结果是该数组中每个元素都调用一个提供的函数后返回的结果<br> 举例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Array1 = [1, 4, 9, 6];</span><br><span class="line">// pass a <span class="keyword">function</span> to map</span><br><span class="line"></span><br><span class="line">const map1 = array1.map(x =&gt; x * 2);</span><br><span class="line">console.log(map1);</span><br><span class="line">// expected output: [2, 8, 18, 12]</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var newArray = arr.map(<span class="keyword">function</span> callback(currentValue[, index[, array]])) &#123;</span><br><span class="line"><span class="built_in">return</span> element <span class="keyword">for</span> new_array</span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback</span><br></pre></td></tr></table></figure><p>生成新的数组函数，使用三个参数</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentValue</span><br></pre></td></tr></table></figure><p> callback数组中正在处理的当前元素.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index</span><br></pre></td></tr></table></figure><p> (可选) callback 数组中正在处理的当前元素的索引.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array</span><br></pre></td></tr></table></figure><p>(可选)执行callback函数时使用的this值。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>一个新数组，每个元素都是回调函数的结果。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>map方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值(包括undefined)组合起来形成一个新数组。callback函数只会在有值的索引上被调用；那些从来没被赋过值或者使用delete删除的索引则不会被调用。<br>callback 函数会被自动传入三个参数：数组元素、元素索引、原数组本身。<br>如果thisArg参数有值，则每次callback函数被调用的时候，this都会指向thisArg参数上的这个对象.如果省略了thisArg参数，后者赋值为null活undefined，则this指向全局对象。<br>map不修改调用它的原数组本身(当然可以在callback执行时改变原数组).<br>使用map方法处理数组时，数组元素的范围在callback方法第一次调用之前就已经确定了。在map方法执行的过程中:原数组中新增加的元素将不会被callback访问到；若已经存在的元素被改变或删除了，则他们的传递到callback的值map方法便利到它们的那一时刻的值;而被删除的元素不会被访问到。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="求数组中每个元素的平方根"><a href="#求数组中每个元素的平方根" class="headerlink" title="求数组中每个元素的平方根"></a>求数组中每个元素的平方根</h4><p>下面的代码创建了一个新数组，值为原数组中对应数字的平方根</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 4, 9];</span><br><span class="line">var roots = numbers.map(Math.sqrt);</span><br><span class="line">// roots的值为[1,2,3], numbers的值仍为[1,4,9]</span><br></pre></td></tr></table></figure><h4 id="使用map重新格式化数组中的对象"><a href="#使用map重新格式化数组中的对象" class="headerlink" title="使用map重新格式化数组中的对象"></a>使用map重新格式化数组中的对象</h4><p>以下代码使用一个包含对象的数组来重新创建一个格式化的数组.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var kvArray = [&#123;key: 1, value: 10&#125;,</span><br><span class="line">  &#123;key: 2, value: 20&#125;,</span><br><span class="line">  &#123;key: 3, value: 30&#125;,</span><br><span class="line"> ];</span><br><span class="line">var reformattedArray = kvArray.map(<span class="keyword">function</span>(obj) &#123;</span><br><span class="line">var rObj = &#123;&#125;;</span><br><span class="line">rObj[obj.key] = obj.value;</span><br><span class="line"><span class="built_in">return</span> rObj;</span><br><span class="line">&#125;);</span><br><span class="line">// reforamttedArray 数组为: [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;];</span><br><span class="line">// kvArray 数组未被修改</span><br><span class="line">// [&#123;key: 1, value: 10&#125;,</span><br><span class="line">//&#123;key: 2, value: 20&#125;,</span><br><span class="line">//&#123;key: 3, value: 30&#125;]</span><br></pre></td></tr></table></figure><h4 id="使用一个包含一个参数的函数来mapping-构建-一个数字数组"><a href="#使用一个包含一个参数的函数来mapping-构建-一个数字数组" class="headerlink" title="使用一个包含一个参数的函数来mapping(构建)一个数字数组"></a>使用一个包含一个参数的函数来mapping(构建)一个数字数组</h4><p>下面的代码表示了当函数需要一个参数时map的工作方式。当map循环便利原始数组时，这个参数回自动被分配成数组中对应的每个元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 4, 9];</span><br><span class="line">var doubles = numbers.map(<span class="keyword">function</span>(item) =&gt; &#123;</span><br><span class="line"><span class="built_in">return</span> num * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// doubles数组的值为: [2, 8, 18];</span><br><span class="line">// numbers数组未被修改 [1, 4, 9]</span><br></pre></td></tr></table></figure><h4 id="一般的map方法"><a href="#一般的map方法" class="headerlink" title="一般的map方法"></a>一般的map方法</h4><p>下面的例子演示如何在一个String上使用map方法获取字符串中每个字符多对应的ASCII码组成的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map = Array.prototype.map;</span><br><span class="line">var a = map.call(<span class="string">'Hello World'</span>, <span class="keyword">function</span>(x) &#123;</span><br><span class="line"><span class="built_in">return</span> x.charCodeAt(0);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="querySelectorAll-应用"><a href="#querySelectorAll-应用" class="headerlink" title="querySelectorAll 应用"></a>querySelectorAll 应用</h4><p>下面代码展示了如何去遍历用querySelectorAll 得到的动态对象集合。在这里，我们获得了文档里所有选中的选项，并将其打印:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var elems =document.querySelectorAll(<span class="string">'select option:checked'</span>);</span><br><span class="line">var values = Array.prototype.map.call(elems. <span class="keyword">function</span>(obj) &#123;</span><br><span class="line"><span class="built_in">return</span> obj.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="使用技巧案例"><a href="#使用技巧案例" class="headerlink" title="使用技巧案例"></a>使用技巧案例</h4><p>通常情况下，map方法中的callback函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着map只给callback传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 下面的语句返回什么呢:</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(parseInt);</span><br><span class="line">// 你可能觉得会是 [1, 2, 3];</span><br><span class="line">// 但实际结果是[1, NaN, NaN];</span><br><span class="line"></span><br><span class="line">// 通常使用parseInt时，只需要传递一个参数</span><br><span class="line">// 但实际上，parseInt可以有两个参数，第二个参数是进制数</span><br><span class="line">// 可以通过语句 <span class="string">'alert(parseInt.length) === 2'</span>来验证</span><br><span class="line">// map方法在调用callback函数时，会给它传递三个参数：当前正在遍历的元素，元素索引，原数组本身。</span><br><span class="line">// 第三个参数parseInt 会忽视，但第二个参数不会，也就是说，parseInt把传过来的索引值当成进制数来使用，从而返回了NaN</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> returnInt (element) &#123;</span><br><span class="line"><span class="built_in">return</span> parseInt(element, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(returnInt); // [1, 2, 3] 意料之中的结果</span><br><span class="line"></span><br><span class="line">// 也可以使用简单的箭头函数，结果同上</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map( str =&gt; parseInt(str));</span><br><span class="line"></span><br><span class="line">// 一个简单的方式:</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(Number); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 与`parseInt`不同，下面的结果会返回浮点数或指数</span><br><span class="line">[<span class="string">'1.1'</span>, <span class="string">'2.2e2'</span>, <span class="string">'3e300'</span>].map(Number); // [1.1, 220, 3e+300]</span><br></pre></td></tr></table></figure><h4 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h4><p>map是在最近的ECMA-262 标准中新添加的方法；所以一些旧版本的浏览器可能没有实现该方法。在那些没有原生支持map方法的浏览器中，你可以使用下面的Javascript代码来实现它。所使用的算法正式ECMA-262,第五版规定的。假定Object,TypeError, 和Array有他们的原始值。而且callback.call的原始值也是Function.prototype.call</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 实现ECMA-262， Edition 5,15.4.4.19</span><br><span class="line"> //参考： http://es5.github/com/<span class="comment">#x15.4.4.19</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!Array.prototype.map) &#123;</span><br><span class="line"> Array.prototype.map = <span class="keyword">function</span>(callback, thisArg) &#123;</span><br><span class="line"> var T,A,k;</span><br><span class="line"> <span class="keyword">if</span>(this == null) &#123;</span><br><span class="line"> throw new TypeError(<span class="string">' this is null or not defined'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 1.将0赋值为调用map方法的数组</span><br><span class="line"> var 0 = Object(this);</span><br><span class="line"></span><br><span class="line"> // 2.将len赋值为数组0的长度</span><br><span class="line"> var len = 0.length &gt;&gt;&gt; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 3.如果callback 不是函数，则跑出TypeError异常</span><br><span class="line"> <span class="keyword">if</span> (Object.prototype.toString.call(callback) != <span class="string">'[object Function]'</span>) &#123;</span><br><span class="line"> throw new TypeError(callback + <span class="string">' is not a function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4. 如果参数thisArg有值，则将T赋值为thisArg;</span><br><span class="line"><span class="keyword">if</span> (thisArg) &#123;</span><br><span class="line">T = thisArg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 5. 创建新数组A,长度为原数组0长度len</span><br><span class="line">A = new Array(len);</span><br><span class="line"></span><br><span class="line">// 6. 将k赋值为0</span><br><span class="line">k = 0;</span><br><span class="line"></span><br><span class="line">// 7. 当k &lt; len时，执行循环</span><br><span class="line"><span class="keyword">while</span>(k &lt; len) &#123;</span><br><span class="line">var kValue, mappedValue;</span><br><span class="line">// 遍历0，k为原数组索引</span><br><span class="line"><span class="keyword">if</span> (k <span class="keyword">in</span> 0) &#123;</span><br><span class="line">// kValue为索引k对应的值</span><br><span class="line">kValue = 0[k];</span><br><span class="line"></span><br><span class="line">// 执行callback,this指向T，参数有三个，分别是kValue:值，k:索引，0:原数组</span><br><span class="line">mappedValue = callback.call(T,kValue,k,0);</span><br><span class="line">// 返回值添加到新数组A中</span><br><span class="line">A[k] = mappedValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// k自增1</span><br><span class="line">k ++;</span><br><span class="line">&#125;</span><br><span class="line">// 返回新数组</span><br><span class="line"><span class="built_in">return</span> A;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js之map</title>
      <link href="/2019/06/22/js%E4%B9%8Bmap/"/>
      <url>/2019/06/22/js%E4%B9%8Bmap/</url>
      
        <content type="html"><![CDATA[<p>对比学习 Array.prototype.map 与 js的 map</p><a id="more"></a><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>  <strong>map</strong> 对象保存键值对。任何值（对象或原始值）都可以作为一个键或一个值。</p><h3 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Map([iterable])</span><br></pre></td></tr></table></figure><p>2.1 参数</p><p> <em>iterable</em>可以是数组或者其他iterabled对象，其元素为键值对（两个元素的数组，例如[[1: ‘one’],[2: ‘two’]]）。每个键值对都会添加到 <strong>新的Map</strong>。<em>null</em> 会被当作 <em>undefined</em></p><h3 id="三、-描述"><a href="#三、-描述" class="headerlink" title="三、 描述"></a>三、 描述</h3><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 <em>for…of</em>循环在每次迭代后会返回一个形式为[key,value]数组。</p><h4 id="键的相等（Key-equality）"><a href="#键的相等（Key-equality）" class="headerlink" title="键的相等（Key equality）"></a>键的相等（Key equality）</h4><p>键的比较是基于”Same ValueZero”算法： <em>NaN</em> 是与 <em>NaN</em> 相等的（虽然 <em>NaN !== NaN</em>）,剩下所有其他的值是根据 <strong>===</strong> 运算符的结果判断是否相等。在目前的ECMAScript规范中，-0 和 +0 被认为是相等的，尽管在早期的草案中并不是这样。</p><h4 id="Objects-和-Maps的比较"><a href="#Objects-和-Maps的比较" class="headerlink" title="Objects 和 Maps的比较"></a>Objects 和 Maps的比较</h4><p> Objects 和 Maps 类似的是，他们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成Maps使用。不过Maps和Objects有一些重要的区别，在下列情况里使用Map会是更好的选择。</p><p>1、 一个Object的键只能是<em>字符串</em>或者<em>Symbols</em>，但一个Map的键可以是<strong>任意值</strong>，包括函数、对象、基本类型。<br>2、 Map中的键值是有序的，而添加到对象中的键则不是。因此，当对他进行遍历时，Map对象时按插入的顺序返回键值。<br>3、 你可以通过<em>size</em>属性直接获取一个<em>Map</em>的键值对个数，而<em>Object</em>的键值对个数只能手动计算。<br>4、 Map可直接迭代，而Object的迭代需要先获取他的键值数组，然后再进行迭代。<br>5、 Object都有自己的原型，原型链上的键名有可能和你自己对象上的设置的键名产生冲突。虽然ES5开始可以用 <em>map = Object.create(null)</em> 来创建一个没有原型的对象，但是这种用法不太常见。<br>6、 Map在涉及频繁增删键值对的场景下会有些性能优势。</p><h3 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.length</span><br></pre></td></tr></table></figure><p>  属性length的值为0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get Map[@@species]</span><br></pre></td></tr></table></figure><p>本构造函数用于创建派生对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype</span><br></pre></td></tr></table></figure><p>表示Map构造器的原型。允许添加属性从而应用于所有的Map对象</p><h3 id="五、Map-实例"><a href="#五、Map-实例" class="headerlink" title="五、Map 实例"></a>五、Map 实例</h3><p>所有的Map对象实例都会继承 Map.prototype</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.constructor</span><br></pre></td></tr></table></figure><p>  返回一个函数，它创建了实例的原型。默认时Map函数</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.size</span><br></pre></td></tr></table></figure><p>  返回Map对象的键/值对的数量</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.clear()</span><br></pre></td></tr></table></figure><p>  移除Map对象的所有键/值对。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.delete(key)</span><br></pre></td></tr></table></figure><p>  如果Map对象中存在该元素，则移除它并返回true；否则如果该元素不存在则返回false</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.entries()</span><br></pre></td></tr></table></figure><p>  返回一个新的 <em>Iterator</em> 对象，它按插入顺序包含了Map对象中每个元素的<strong>[key,value]</strong>数组。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.forEach(callbackFn[, thisArg])</span><br></pre></td></tr></table></figure><p>  按插入顺序，为Map对象里的每一键值对调用一次callbackFn函数。如果forEach 提供了thisArg,它将在每次回调中作为this值。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.get(key)</span><br></pre></td></tr></table></figure><p>  返回键对应的值，如果不存在，则返回undefined</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.has(key)</span><br></pre></td></tr></table></figure><p>  返回一个布尔值，表示Map实例是否包含键对应的值。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.keys()</span><br></pre></td></tr></table></figure><p>  返回一个新的 <em>Iterator</em>对象，他按插入顺序包含了Map对象中的每个元素的<strong>键</strong>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.set(key,value)</span><br></pre></td></tr></table></figure><p>  设置Map对象中键的值。返回该Map对象。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype.values()</span><br></pre></td></tr></table></figure><p>  返回一个新的<em>Iterator</em>对象，他按插入顺序包含了Map对象中每个元素的<strong>值</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map.prototype[@@iterator]()</span><br></pre></td></tr></table></figure><p>  返回一个新的 <em>Iterator</em>对象，他按插入顺序包含了Map对象中的每个元素的<strong>[key,value]数组</strong>。</p><h3 id="六、示例"><a href="#六、示例" class="headerlink" title="六、示例"></a>六、示例</h3><h4 id="使用Map对象"><a href="#使用Map对象" class="headerlink" title="使用Map对象"></a>使用Map对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyObj = &#123;&#125;,</span><br><span class="line">    keyFunc = <span class="function"><span class="title">function</span></span>() &#123;&#125;,</span><br><span class="line">    keyString = <span class="string">'a string'</span>;</span><br><span class="line"></span><br><span class="line">  // 添加键</span><br><span class="line"> myMap.set(keyString, <span class="string">"和键'a string' 关联的值"</span>);</span><br><span class="line"> myMap.set(keyObj, <span class="string">'和键keyObj关联的值'</span>);</span><br><span class="line"> myMap.set(keyFunc, <span class="string">'和键keyFunc关联的值'</span>);</span><br><span class="line"></span><br><span class="line"> myMap.size(); // 3</span><br><span class="line"></span><br><span class="line"> // 读取值</span><br><span class="line"> myMap.get(keyString); // 和键<span class="string">'a string'</span> 关联的值</span><br><span class="line"> myMap.get(keyObj); // 和键keyObj关联的值</span><br><span class="line"> myMap.get(keyFunc); // 和键keyFunc关联的值</span><br><span class="line"></span><br><span class="line"> myMap.get(<span class="string">'a string'</span>); // 和键<span class="string">'a string'</span> 关联的值</span><br><span class="line"> myMap.get(&#123;&#125;); // undefined,因为 keyObj !== &#123;&#125;</span><br><span class="line"> myMap.get(<span class="function"><span class="title">function</span></span>() &#123;&#125;); // undefined, 因为keyFunc !== <span class="function"><span class="title">funcetion</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="将NaN作为Map的键"><a href="#将NaN作为Map的键" class="headerlink" title="将NaN作为Map的键"></a>将NaN作为Map的键</h4><p>NaN 也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN 返回 true)， 但下面的例子表明，NaN作为Map的键来说是没有区别的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, <span class="string">'not a number'</span>);</span><br><span class="line">MyMap.get(NaN); // <span class="string">'not a number'</span></span><br><span class="line"></span><br><span class="line">var otherNaN = Number(<span class="string">'foo'</span>);</span><br><span class="line">myMap.get(otherNaN); // <span class="string">'not a number'</span></span><br></pre></td></tr></table></figure><h4 id="使用-for…of-方法迭代Map"><a href="#使用-for…of-方法迭代Map" class="headerlink" title="使用 for…of 方法迭代Map"></a>使用 for…of 方法迭代Map</h4><p>Map可以使用<em>for…of</em>循环来实现迭代</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(0, <span class="string">'zero'</span>);</span><br><span class="line">myMap.set(1, <span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">for</span>(var [key, value] of myMap) &#123;</span><br><span class="line">console.log(key + <span class="string">' = '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// 将会展示两个<span class="built_in">log</span>.一个是<span class="string">'0 = zero'</span> 另一个是 <span class="string">'1 = one'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (var key of myMap.keys()) &#123;</span><br><span class="line">console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// 将会展示两个<span class="built_in">log</span>，一个是<span class="string">'0'</span>,一个是<span class="string">'1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var value of myMap.values()) &#123;</span><br><span class="line">console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// 将会展示两个<span class="built_in">log</span>,一个是<span class="string">'zero'</span> 另一个是<span class="string">'one'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(var [key, value] of myMap.extries()) &#123;</span><br><span class="line">  console.log(key + <span class="string">' = '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">// 将会展示两个<span class="built_in">log</span>，一个是 0 = zero 另一个是 1 = one</span><br></pre></td></tr></table></figure><h4 id="使用forEach-方法迭代Map"><a href="#使用forEach-方法迭代Map" class="headerlink" title="使用forEach 方法迭代Map"></a>使用forEach 方法迭代Map</h4><p> Map也可以通过<em>forEach()</em>方法迭代</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myMap.forEach(<span class="keyword">function</span>(value, key) &#123;</span><br><span class="line">  console.log(key + <span class="string">' = '</span> + value);</span><br><span class="line">&#125;, myMap);</span><br><span class="line">// 将会展示两个logs 一个是 0 = zero 另一个是 1 = one</span><br></pre></td></tr></table></figure><h4 id="Map与数组的关系"><a href="#Map与数组的关系" class="headerlink" title="Map与数组的关系"></a>Map与数组的关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var kvArray = [[<span class="string">"key1"</span>, <span class="string">"value1"</span>], [<span class="string">"key2"</span>, <span class="string">"value2"</span>]];</span><br><span class="line"></span><br><span class="line">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span><br><span class="line"></span><br><span class="line">var myMap = new Map(kvArray);</span><br><span class="line"></span><br><span class="line">myMap.get(<span class="string">"key1"</span>); // 返回值为 value1</span><br><span class="line"></span><br><span class="line">// 使用Array.from 函数可以将一个Map对象转换成一个二维键值对数组</span><br><span class="line">console.log(Array.from(myMap)); // 输出和kvArray相同的数组</span><br><span class="line"></span><br><span class="line">// 或者在键或者值的迭代器上使用Array.from, 进而得到只含有键或者值的数组</span><br><span class="line">console.log(Array.from(myMap.keys())); // 输出[<span class="string">'key1'</span>, <span class="string">'key2'</span>];</span><br></pre></td></tr></table></figure><h4 id="复制或合并Maps"><a href="#复制或合并Maps" class="headerlink" title="复制或合并Maps"></a>复制或合并Maps</h4><p>Map能像数组一样被复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var original = new Map([1, <span class="string">'one'</span>]);</span><br><span class="line">var <span class="built_in">clone</span> = new Map(original);</span><br><span class="line"></span><br><span class="line">console.log(clone.get(1)); // one</span><br><span class="line">console.log(original === <span class="built_in">clone</span>); // <span class="literal">false</span>. Useful <span class="keyword">for</span> shallow comparison</span><br></pre></td></tr></table></figure><p><strong>请记住，数据本身未被克隆</strong></p><p>Map对象间可以进行合并，但是会保持键的唯一性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var first = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>]</span><br><span class="line">]);</span><br><span class="line">var second = new Map([</span><br><span class="line">[1, <span class="string">'uno'</span>],</span><br><span class="line">[2, <span class="string">'doc'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的</span><br><span class="line"></span><br><span class="line">// 展开运算符本质上是将Map对象转换成数组</span><br><span class="line"></span><br><span class="line">var merged = new Map([...first, ...second]);</span><br><span class="line">console.log(merged.get(1)); // uno</span><br><span class="line">console.log(merged.get(2)); // doc</span><br><span class="line">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure><p>Map对象也能与数组合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var first = new Map([</span><br><span class="line">  [1, <span class="string">'one'</span>],</span><br><span class="line">  [2, <span class="string">'two'</span>],</span><br><span class="line">  [3, <span class="string">'three'</span>]</span><br><span class="line"> ]);</span><br><span class="line">var second = new Map([</span><br><span class="line">[1, <span class="string">'uno'</span>],</span><br><span class="line">[2, <span class="string">'doc'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">// Map对象同数组进行合并时。如果有重复的键值，则后面的会覆盖前面的。</span><br><span class="line">var merged = new Map([...first, ...second, [1, <span class="string">'eins'</span>]]);</span><br><span class="line">onsole.log(merged.get(1)); // eins</span><br><span class="line">console.log(merged.get(2)); // doc</span><br><span class="line">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看javascript技巧有感</title>
      <link href="/2019/06/21/%E7%9C%8Bjavascript%E6%8A%80%E5%B7%A7%E6%9C%89%E6%84%9F/"/>
      <url>/2019/06/21/%E7%9C%8Bjavascript%E6%8A%80%E5%B7%A7%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>这段时间听同事面试校招生，发现自己原生js很弱，需要狂补，以下为看<a href="https://mp.weixin.qq.com/s/X6ks8HrhAXvIjkcnZ9qMLw" target="_blank" rel="noopener">《一个合格的中级前端工程师要掌握的javaScript技巧》</a>有感</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="这段时间听同事面试校招生，发现自己原生js很弱，需要狂补，以下为看《一个合格的中级前端工程师要掌握的javaScript技巧》有感"><a href="#这段时间听同事面试校招生，发现自己原生js很弱，需要狂补，以下为看《一个合格的中级前端工程师要掌握的javaScript技巧》有感" class="headerlink" title="这段时间听同事面试校招生，发现自己原生js很弱，需要狂补，以下为看《一个合格的中级前端工程师要掌握的javaScript技巧》有感"></a>这段时间听同事面试校招生，发现自己原生js很弱，需要狂补，以下为看<a href="https://mp.weixin.qq.com/s/X6ks8HrhAXvIjkcnZ9qMLw" target="_blank" rel="noopener">《一个合格的中级前端工程师要掌握的javaScript技巧》</a>有感</h4><h4 id="1、判断对象的数据类型"><a href="#1、判断对象的数据类型" class="headerlink" title="1、判断对象的数据类型"></a>1、判断对象的数据类型</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const isType = <span class="built_in">type</span> =&gt; target =&gt; `[Object <span class="variable">$&#123;type&#125;</span>]` === Object.prototype.toString.call(target);</span><br><span class="line">const isArray = isType(<span class="string">'Array'</span>);</span><br><span class="line">console.log(isArray([])); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>以上isType为高阶函数，可翻译如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const isType = (<span class="built_in">type</span>) =&gt; &#123;</span><br><span class="line">  (target) =&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> `[Object <span class="variable">$&#123;type&#125;</span>]` === Object.prototype.toString.call(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入type传入参数时首字母大写）</p><p><em>不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上，因为call会将第一个参数进行装箱操作</em></p><h4 id="2、es5实现数组map方法"><a href="#2、es5实现数组map方法" class="headerlink" title="2、es5实现数组map方法"></a>2、es5实现数组map方法</h4><p> 对于map方法的运用，我们可以在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">mdn</a>中查看到对应的用法，如下</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const selfMap = <span class="keyword">function</span>(fn, context) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="built_in">let</span> mappedArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i&lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line">mappedArr.push(fn.call(context, arr[i], i, this)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> mappedArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 值得一提的是,map的第二个参数为第一个参数回调中的this指向，如果第一个参数为箭头函数，那设置第二个this会因为箭头函数的词法绑定而失败。<br>  另外就是对稀疏数组的处理，通过hasOwnProperty来判断当前下标的元素是否存在与数组中</p><h4 id="3-使用reduce实现数组map方法"><a href="#3-使用reduce实现数组map方法" class="headerlink" title="3.使用reduce实现数组map方法"></a>3.使用reduce实现数组map方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const selfMap2 = <span class="keyword">function</span>(fn, context) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="built_in">return</span> arr.reduce((pre,cur,index) =&gt; &#123;</span><br><span class="line"><span class="built_in">return</span> [...pre,fn.call(context, cur, index, this)]</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-ES5实现数组filter方法"><a href="#4-ES5实现数组filter方法" class="headerlink" title="4.ES5实现数组filter方法"></a>4.ES5实现数组filter方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const selfFilter = <span class="keyword">function</span>(fn, context) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="built_in">let</span> filteredArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i&lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line">fn.call(context, arr[i], i, this) &amp;&amp; filteredArr.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> filteredArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-使用reduce实现数组filter方法"><a href="#5-使用reduce实现数组filter方法" class="headerlink" title="5.使用reduce实现数组filter方法"></a>5.使用reduce实现数组filter方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const selfFilter2 = <span class="keyword">function</span> (fn, context)&#123;</span><br><span class="line"><span class="built_in">return</span> this.reduce((pre, cur, index) =&gt; &#123;</span><br><span class="line"><span class="built_in">return</span> fn.call(context, cur, index, this) ? [...pre, cur] : [...pre]</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-ES5实现数组的some方法"><a href="#6-ES5实现数组的some方法" class="headerlink" title="6. ES5实现数组的some方法"></a>6. ES5实现数组的some方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const selfSome = <span class="keyword">function</span>(fn, context) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="keyword">if</span> (!arr.length) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">let</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line"><span class="built_in">let</span> res = fn.call(context, arr[i], i, this);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-ES5实现数组的reduce方法"><a href="#7-ES5实现数组的reduce方法" class="headerlink" title="7.ES5实现数组的reduce方法"></a>7.ES5实现数组的reduce方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">@description 找到第一个empty的元素的下标</span><br><span class="line">@param &#123;Array&#125; arr - 参看说明</span><br><span class="line">@param &#123;Number&#125; &#123;initIndex&#125; - 遍历的起始下标</span><br><span class="line">@<span class="built_in">return</span> &#123;Number&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const findRealElementIndex = <span class="keyword">function</span>(arr, initIndex) &#123;</span><br><span class="line"><span class="built_in">let</span> index;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = initIndex || 0, i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line">index = i;</span><br><span class="line"><span class="built_in">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const selfReduce = <span class="keyword">function</span>(fn, initValue) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="built_in">let</span> res;</span><br><span class="line"><span class="keyword">if</span> (initValue === undefined) &#123;</span><br><span class="line">res= = arr[findRealElementIndex(arr)];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length - 1; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line"><span class="built_in">let</span> realElementIndex = findRealElementIndex(arr, i+1);</span><br><span class="line">res = fn.call(null, res, arr[realElementIndex], realElementIndex, this);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = initValue;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="built_in">continue</span>;</span><br><span class="line">res = fn.call(null, res, arr[i], i, this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为可能存在稀疏数组的关系，所以reduce实现略有点复杂，需要保证跳过稀疏数组，遍历正确的元素和下标</p><h4 id="8-使用reduce-实现数组的flat方法"><a href="#8-使用reduce-实现数组的flat方法" class="headerlink" title="8.使用reduce 实现数组的flat方法"></a>8.使用reduce 实现数组的flat方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const selfFlat = <span class="keyword">function</span>(depth = 1) &#123;</span><br><span class="line"><span class="built_in">let</span> arr = Array.prototype.slice.call(this);</span><br><span class="line"><span class="keyword">if</span> (depth === 0) <span class="built_in">return</span> arr;</span><br><span class="line"><span class="built_in">return</span> arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (Array.isArray(cur)) &#123;</span><br><span class="line"><span class="built_in">return</span> [...pre, ...selfFlat.call(cur, depth - 1)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">return</span> [...pre, ...cur]</span><br><span class="line">&#125;</span><br><span class="line">&#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为slefFlat是依赖this指向的，所以在reduce遍历时需要指定slefFlat的this指向，否则会默认指向window从而发生错误。<br>远离通过reduce遍历数组，遇到数组的某个元素仍是数组，通过ES6的扩展运算符对其进行降维（ES5可以使用concat方法），而这个数组元素可能内部还嵌套数组，所以需要递归调用slefFlat<br>同时原生的falt方法支持一个depth参数表示较为的深度，默认为1即给数组降一层维度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [1, 2, [3, 4], [5, [6, 7]]];</span><br><span class="line">arr.flat();</span><br><span class="line">// 返回为 [1, 2, 3, 4,5, [6, 7]]</span><br><span class="line">// 传入Inifity 会将传入的数组变成一个一维数组</span><br><span class="line">arr.falt(Infinity)</span><br><span class="line">// [1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><p>原理是每递归一次将depth参数减1，如果depth参数为0时，直接返回原数组</p><h4 id="9-实现ES6的classs语法"><a href="#9-实现ES6的classs语法" class="headerlink" title="9.实现ES6的classs语法"></a>9.实现ES6的classs语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> inhertit(subType, superType) &#123;</span><br><span class="line">subType.prototype = Object.create(superType.prototype, &#123;</span><br><span class="line">contructor: &#123;</span><br><span class="line">enumerable: <span class="literal">false</span>,</span><br><span class="line">configurable: <span class="literal">true</span>,</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">value: superType.contructor</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 继承递归</span><br><span class="line">Object.setPrototypeOf(subType, superType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6的class内部时基于寄生组合式继承，它是目前最理想的继承方式，通过Object.create方法创造一个空对象，并将这个空对象继承Object.create方法的参数，再让子类(subType)的原型对象等于这个空对象，就可以实现子类实例的原型等于这个空对象，而这个空对象的原型又等于父类原型对象(superType.peototype)的继承关系。</p><p>而Object.create支持第二个参数，即给生成的空对象定义属性和属性描述符/访问器描述符，我们可以给这个空对象定义一个contructor 属性更加符合默认的继承行为，同时它是不可枚举的内部属性(enumerable: false)</p><p>而ES6的class允许子类继承父类的静态方法和静态属性，而普通的寄生组合式继承只能做到实例与实例之间的继承，对于类与类之间的继承需要额外定义方法，这里使用Object.setPrototypeOf将superType设置为subType的原型，从而能够从父类中继承静态方法和静态属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javaScript Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190403 git 错误操作</title>
      <link href="/2019/04/04/20190403-git-%E9%94%99%E8%AF%AF%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/04/20190403-git-%E9%94%99%E8%AF%AF%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="20190403-git-错误操作"><a href="#20190403-git-错误操作" class="headerlink" title="20190403 git 错误操作"></a>20190403 git 错误操作</h3><p>git merge 与 rebase; git reset</p><a id="more"></a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>   当时把所有的业务代码都写完了，看了pr，想优化下分支中的一些文件，就用了以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span> + 文件路径 // 查找到想要会退的commit，例如commit id 为 saasasa</span><br><span class="line">git reset -- hard saasasa</span><br><span class="line">git push -g origin + 本地分支名</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>  直接导致远程代码被reset了，后提交的所有commit都不存在，导致代码数据全部都没有了，毁灭，难受，心塞，心慌</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reflog show // 查找最近操作的head</span><br><span class="line">git reset + 想要回退的操作的headId</span><br><span class="line">git <span class="built_in">log</span> // 即可看到上一次reset前的<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>注释：例如我操作我本地的分支的一个  git reflog show</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fc2310c9 (HEAD -&gt; git/<span class="built_in">test</span>) HEAD@&#123;0&#125;: checkout: moving from feature/optional-settlement to git/<span class="built_in">test</span></span><br><span class="line">26284977 (origin/feature/optional-settlement, feature/optional-settlement) HEAD@&#123;1&#125;: reset: moving to HEAD</span><br><span class="line">26284977 (origin/feature/optional-settlement, feature/optional-settlement) HEAD@&#123;2&#125;: checkout: moving from git/<span class="built_in">test</span> to feature/optional-settlement</span><br><span class="line">fc2310c9 (HEAD -&gt; git/<span class="built_in">test</span>) HEAD@&#123;3&#125;: reset: moving to HEAD@&#123;2&#125;</span><br><span class="line">d730bc53 (origin/git/<span class="built_in">test</span>) HEAD@&#123;4&#125;: reset: moving to HEAD@&#123;0&#125;</span><br><span class="line">d730bc53 (origin/git/<span class="built_in">test</span>) HEAD@&#123;5&#125;: reset: moving to d730bc5333a6f0054227d9476dffb5dc5308f5e8</span><br><span class="line">fc2310c9 (HEAD -&gt; git/<span class="built_in">test</span>) HEAD@&#123;6&#125;: commit: git测试</span><br><span class="line">5d1965a0 (origin/master, origin/HEAD, master) HEAD@&#123;7&#125;: checkout: moving from master to git/<span class="built_in">test</span></span><br><span class="line">5d1965a0 (origin/master, origin/HEAD, master) HEAD@&#123;8&#125;: checkout: moving from qatest to master</span><br><span class="line">83eede1e (origin/qatest, qatest) HEAD@&#123;9&#125;: commit (merge): 合同</span><br><span class="line">ed915fc5 HEAD@&#123;10&#125;: merge feature/remove-branch: Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line">f3d9ba99 HEAD@&#123;11&#125;: merge feature/customer-log: Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line">26284977 (origin/feature/optional-settlement, feature/optional-settlement) HEAD@&#123;12&#125;: merge feature/optional-settlement: Fast-forward</span><br><span class="line">5d1965a0 (origin/master, origin/HEAD, master) HEAD@&#123;13&#125;: checkout: moving from master to qatest</span><br><span class="line">5d1965a0 (origin/master, origin/HEAD, master) HEAD@&#123;14&#125;: checkout: moving from qatest to master</span><br><span class="line">8254f765 HEAD@&#123;15&#125;: reset: moving to HEAD</span><br><span class="line">8254f765 HEAD@&#123;16&#125;: checkout: moving from feature/optional-settlement to qatest</span><br><span class="line">26284977 (origin/feature/optional-settlement, feature/optional-settlement) HEAD@&#123;17&#125;: commit: 删除注</span><br><span class="line">释 &amp; 字段修改</span><br><span class="line">2f3028b0 HEAD@&#123;18&#125;: commit: 选座优化</span><br></pre></td></tr></table></figure><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>  一、git reset –hard 和  git push -f 和  git pull -f 这些强制性的操作太过于危险，最好不要使用，切勿在公共分支使用</p><p>  二、如果想将某个提交过的文件回退,可以使用如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -- 文件路径</span><br><span class="line">git checkout  + commitId + 文件路径</span><br></pre></td></tr></table></figure><p>这样就可以将文件回退<br>然后用 <code>git push</code> 即可</p><p>  三、 对于分支强拉或者强推 ，最好不要使用 <code>-force</code>  ，可以考虑使用 <code>rebase</code> 操作，不会重新生成 commitId, 操作比较柔和</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack2.x升级到4.x踩坑点</title>
      <link href="/2019/03/05/webpack2-x%E5%8D%87%E7%BA%A7%E5%88%B04-x%E8%B8%A9%E5%9D%91%E7%82%B9/"/>
      <url>/2019/03/05/webpack2-x%E5%8D%87%E7%BA%A7%E5%88%B04-x%E8%B8%A9%E5%9D%91%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>BD项目webpack 2.X 生 4.X踩坑指南<br><a id="more"></a></p><h4 id="升级时间"><a href="#升级时间" class="headerlink" title="升级时间"></a>升级时间</h4><p>2019-03-03 ~ 2019-03-04</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>升级未完成 20190305业务堆积</p><h4 id="升级遇到问题汇总"><a href="#升级遇到问题汇总" class="headerlink" title="升级遇到问题汇总"></a>升级遇到问题汇总</h4><h4 id="一、旧项目直接升级webpack报错（npm-install-webpack-）"><a href="#一、旧项目直接升级webpack报错（npm-install-webpack-）" class="headerlink" title="一、旧项目直接升级webpack报错（npm install webpack ）"></a>一、旧项目直接升级webpack报错（npm install webpack ）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 此部分从网上粘贴，报错大致类似</span><br><span class="line"></span><br><span class="line">peerDependencies link ajv@5.5.2 <span class="keyword">in</span> D:\work-span\travel\Travel\node_modules\_ajv-keywords@2.1.1@ajv-keywords unmet with D:\work-span\travel\Travel\node_modules\ajv(6.6.2)</span><br><span class="line">peerDependencies WARNING webpack-dev-server@^3.1.14 requires a peer of webpack@^4.0.0 but webpack@3.12.0 was installed</span><br><span class="line">peerDependencies WARNING webpack-cli@^3.1.2 requires a peer of webpack@^4.x.x but webpack@3.12.0 was installed</span><br><span class="line">peerDependencies WARNING webpack-dev-server@3.1.14 › webpack-dev-middleware@3.4.0 requires a peer of webpack@^4.0.0 but webpack@3.12.0 was installed</span><br><span class="line">deprecate autoprefixer@7.2.6 › browserslist@^2.11.3 Browserslist 2 could fail on reading Browserslist 3.0 config used <span class="keyword">in</span> other tools.</span><br><span class="line">deprecate css-loader@0.28.11 › cssnano@3.10.0 › autoprefixer@6.7.7 › browserslist@^1.7.6 Browserslist 2</span><br><span class="line">could fail on reading Browserslist 3.0 config used <span class="keyword">in</span> other tools.</span><br><span class="line">deprecate eslint@4.19.1 › file-entry-cache@2.0.0 › flat-cache@1.3.4 › circular-json@^0.3.1 CircularJSON</span><br><span class="line">is <span class="keyword">in</span> maintenance only, flatted is its successor.</span><br><span class="line">deprecate webpack-bundle-analyzer@2.13.1 › bfj-node4@^5.2.0 Switch to the `bfj` package <span class="keyword">for</span> fixes and new features!</span><br><span class="line">Recently updated (since 2018-12-18): 9 packages (detail see file D:\work-span\travel\Travel\node_modules\.recently_updates.txt)</span><br><span class="line">√ All packages installed (928 packages installed from npm registry, used 38s(network 37s), speed 529.19</span><br><span class="line">kB/s, json 802(1.72MB), tarball 17.22MB)</span><br></pre></td></tr></table></figure><p> 原因：旧系统本身安装了webpack以及其他包依赖，在升级之前需要先卸载或删除，然后升级才能成功，如下:升级后的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall webpack</span><br><span class="line">npm install webpack</span><br></pre></td></tr></table></figure><h4 id="二、将webpack-webpack-cli-webpack-server-升级成功后，npm-run-build-报错"><a href="#二、将webpack-webpack-cli-webpack-server-升级成功后，npm-run-build-报错" class="headerlink" title="二、将webpack webpack-cli webpack-server 升级成功后，npm run build 报错"></a>二、将webpack webpack-cli webpack-server 升级成功后，npm run build 报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack4 Error: webpack.optimize.CommonsChunkPlugin has been removed,</span><br><span class="line">      please use config.optimization.splitChunks instead</span><br></pre></td></tr></table></figure><p>webpack4.x 版本与 2.x 区别之一就是webpack.optimize.CommonsChunkPlugin被移除了，原先在项目中的不可用了，需要用新的config.optimization.splitChunks，原先用法如图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'common'</span>,</span><br><span class="line">  filename: isBuild ? <span class="string">'commons-[chunkhash].min.js'</span> : <span class="string">'commons.js'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改进后的用法为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      filename: isBuild ? <span class="string">'commons-[chunkhash].min.js'</span> : <span class="string">'commons.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'common'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、如上，splitChunks的写法还有问题，报错信息如图"><a href="#三、如上，splitChunks的写法还有问题，报错信息如图" class="headerlink" title="三、如上，splitChunks的写法还有问题，报错信息如图:"></a>三、如上，splitChunks的写法还有问题，报错信息如图:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">chunk optimization</span><br><span class="line">SplitChunksPlugin/Users/nieyuling/space/bd-node/node_modules/webpack/lib/optimize/SplitChunksPlugin.js:740</span><br><span class="line">throw new Error(</span><br><span class="line">^</span><br><span class="line">Error: SplitChunksPlugin: You are trying to <span class="built_in">set</span> a filename <span class="keyword">for</span> a chunk <span class="built_in">which</span></span><br><span class="line">is (also) loaded on demand. The runtime can only handle loading of chunks</span><br><span class="line"><span class="built_in">which</span> match the chunkFilename schema. Using a custom filename would fail</span><br><span class="line">at runtime. (cache group: vendors)</span><br></pre></td></tr></table></figure><p>原因：少写 chunks: ‘initial’,<br>加后为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'initial'</span>,</span><br><span class="line">    name: <span class="string">'common'</span>,</span><br><span class="line">    filename: isBuild ? <span class="string">'commons-[chunkhash].min.js'</span> : <span class="string">'commons.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  runtimeChunk: &#123;</span><br><span class="line">    name: <span class="string">'common'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、-npm-run-build-后-html-webpack-plugin-before-html-generation-报错"><a href="#四、-npm-run-build-后-html-webpack-plugin-before-html-generation-报错" class="headerlink" title="四、 npm run build 后 html-webpack-plugin-before-html-generation 报错"></a>四、 npm run build 后 html-webpack-plugin-before-html-generation 报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/Users/nieyuling/space/bd-node/node_modules/add-asset-html-webpack-plugin</span><br><span class="line">/lib/index.js:119</span><br><span class="line">  beforeGenerationHook.tapPromise(<span class="string">'AddAssetHtmlPlugin'</span>, htmlPluginData =</span><br><span class="line">                          ^</span><br><span class="line">TypeError: Cannot <span class="built_in">read</span> property <span class="string">'tapPromise'</span> of undefined</span><br></pre></td></tr></table></figure><p>原因： html-webpack-plugin版本有问题，安装稳定版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin@next</span><br></pre></td></tr></table></figure><h4 id="五、webpack提示Cannot-read-property-‘properties’-of-undefined错误"><a href="#五、webpack提示Cannot-read-property-‘properties’-of-undefined错误" class="headerlink" title="五、webpack提示Cannot read property ‘properties’ of undefined错误"></a>五、webpack提示Cannot read property ‘properties’ of undefined错误</h4><p>解决办法:<br>一、将webpack升级到稳定版，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-cli@next</span><br></pre></td></tr></table></figure><p>二、将对应的依赖包卸载再重新装，可能是包老的原因</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h4 id="六、Tapable-plugin-is-deprecated-Use-new-API-on-hooks-instead"><a href="#六、Tapable-plugin-is-deprecated-Use-new-API-on-hooks-instead" class="headerlink" title="六、Tapable.plugin is deprecated. Use new API on .hooks instead"></a>六、Tapable.plugin is deprecated. Use new API on <code>.hooks</code> instead</h4><p> 原因： 在使用extract-text-webpack-plugin给webpack打包时出现报错，extract-text-webpack-plugin目前版本不支持webpack4。需要将extract-text-webpack-plugin升级到稳定版或者最新版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall extract-text-webpack-plugin</span><br><span class="line">npm install extract-text-webpack-plugin@next</span><br></pre></td></tr></table></figure><h4 id="七、htmlWebpackPluginBeforeHtmlGeneration-tapPromise-为undefined"><a href="#七、htmlWebpackPluginBeforeHtmlGeneration-tapPromise-为undefined" class="headerlink" title="七、htmlWebpackPluginBeforeHtmlGeneration.tapPromise 为undefined"></a>七、htmlWebpackPluginBeforeHtmlGeneration.tapPromise 为undefined</h4><p>报错版本：</p><p>“webpack”: “^4.29.6”,</p><p>“html-webpack-plugin”: “^2.28.0”,</p><p>需要将html-webpack-plugin升级到最新版或者稳定版</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uminstall html-webpack-plugin</span><br><span class="line">npm install html-webpack-plugin@next</span><br></pre></td></tr></table></figure><h4 id="八、webpack-config-js配置遇到Error-Cannot-find-module-‘-babel-core’-amp-amp-Cannot-find-module-‘-babel-plugin-transform-react-jsx’-问题"><a href="#八、webpack-config-js配置遇到Error-Cannot-find-module-‘-babel-core’-amp-amp-Cannot-find-module-‘-babel-plugin-transform-react-jsx’-问题" class="headerlink" title="八、webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’&amp;&amp;Cannot find module ‘@babel/plugin-transform-react-jsx’ 问题"></a>八、webpack.config.js配置遇到Error: Cannot find module ‘@babel/core’&amp;&amp;Cannot find module ‘@babel/plugin-transform-react-jsx’ 问题</h4><p> 原因：babel-core 应用 babel-loader的版本用起来须对应上，一般来说，高版本的需要需要同时运用，当时 babel-code的版本为”@babel/core”: “^7.3.4”, 而 “babel-loader”:8.x 两个版本同时运用会出错，需要将”babel-loader”的版本降低:降低后为 “babel-loader”: “^6.2.4”</p><h4 id="官方解释：官方默认babel-loader-babel-对应的版本需要一致-即babel-loader需要搭配最新版本babel"><a href="#官方解释：官方默认babel-loader-babel-对应的版本需要一致-即babel-loader需要搭配最新版本babel" class="headerlink" title="官方解释：官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel"></a>官方解释：官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel</h4><h4 id="九、cannot-find-‘less-loader’"><a href="#九、cannot-find-‘less-loader’" class="headerlink" title="九、cannot find ‘less-loader’"></a>九、cannot find ‘less-loader’</h4><p>less-loader版本低，需要先卸载less以及less-loader，再install重新安装</p><h4 id="十、Cannot-read-property-‘fileLoader’-of-undefined"><a href="#十、Cannot-read-property-‘fileLoader’-of-undefined" class="headerlink" title="十、Cannot read property ‘fileLoader’ of undefined"></a>十、Cannot read property ‘fileLoader’ of undefined</h4><p> file-loader版本低，需要先卸载less以及less-loader，再install重新安装</p><h4 id="十、less-version-3-9-0-is-not-currently-supported"><a href="#十、less-version-3-9-0-is-not-currently-supported" class="headerlink" title="十、less version 3.9.0 is not currently supported"></a>十、less version 3.9.0 is not currently supported</h4><p>原因: less版本过高，与package内gulp-less版本不搭</p><p>做法: less降低版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less</span><br><span class="line">npm install less@2.7.0</span><br></pre></td></tr></table></figure><h4 id="十一、Cannot-read-property-‘hash’-of-undefined"><a href="#十一、Cannot-read-property-‘hash’-of-undefined" class="headerlink" title="十一、Cannot read property ‘hash’ of undefined"></a>十一、Cannot read property ‘hash’ of undefined</h4><p>报错信息意思是htmlWebpackPlugin插件有问题</p><p>原因：webpack打包有问题<br>也就是webpack配置有问题<br>跟斯腾（同事）请教，可以先只配置报错信息的插件，也就是htmlWebpackPlugin插件，然后一步步注释放开，最后判断问题在插件speed-measure-webpack-plugin上，将其不使用，build正常</p><h4 id="十二、build正常，dev-start正常以及dev-server正常，但是本地浏览器访问时，页面空白，没有html渲染"><a href="#十二、build正常，dev-start正常以及dev-server正常，但是本地浏览器访问时，页面空白，没有html渲染" class="headerlink" title="十二、build正常，dev-start正常以及dev-server正常，但是本地浏览器访问时，页面空白，没有html渲染"></a>十二、build正常，dev-start正常以及dev-server正常，但是本地浏览器访问时，页面空白，没有html渲染</h4><h4 id="十三、webpack4-一些plugin移除，例如："><a href="#十三、webpack4-一些plugin移除，例如：" class="headerlink" title="十三、webpack4 一些plugin移除，例如："></a>十三、webpack4 一些plugin移除，例如：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: webpack.optimize.UglifyJsPlugin has been removed,</span><br><span class="line">please use config.optimization.minimize instead.</span><br></pre></td></tr></table></figure><p>原因： webpack4基于零配置的思想，部分插件被移除，如webpack.optimize.UglifyJsPlugin在webpack4中已经被移除，在optimization对象中配置optimization.minimize=true即可，如果是生产环境的模式（mode：production）下，则该属性默认为true，默认压缩</p><h4 id="十四、webpack4所有都build完毕，本地访问页面空白，打开元素查看dom无html节点元素"><a href="#十四、webpack4所有都build完毕，本地访问页面空白，打开元素查看dom无html节点元素" class="headerlink" title="十四、webpack4所有都build完毕，本地访问页面空白，打开元素查看dom无html节点元素"></a>十四、webpack4所有都build完毕，本地访问页面空白，打开元素查看dom无html节点元素</h4><p>原因，将所有打包文件用chunks方式命名，没有触发chunks渲染<br>解决办法：将打包chunks的方式注释，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">// splitChunks: &#123;</span><br><span class="line">//   chunks: <span class="string">'all'</span>,</span><br><span class="line">//   name: <span class="literal">true</span>,</span><br><span class="line">//   // filename: isBuild ? <span class="string">'common-code-[chunkhash].min.js'</span> : <span class="string">'common-code.js'</span>,</span><br><span class="line">// &#125;,</span><br><span class="line">// runtimeChunk: &#123;</span><br><span class="line">//   name: <span class="string">'runtime'</span></span><br><span class="line">// &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="十五、大部分页面渲染无误，少部分页面渲染有问题，报错信息如下"><a href="#十五、大部分页面渲染无误，少部分页面渲染有问题，报错信息如下" class="headerlink" title="十五、大部分页面渲染无误，少部分页面渲染有问题，报错信息如下"></a>十五、大部分页面渲染无误，少部分页面渲染有问题，报错信息如下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: Command failed: /Users/nieyuling/space/bd-node/node_modules/</span><br><span class="line">freemarker.js/fmpp/fmpp /Users/nieyuling/space/bd-node/client/view/pages/admin/</span><br><span class="line">cinema_activity/index.ftl -C /var/folders/bw/16rd988j6_d_1_rz4r0tnvph0000gn/T/</span><br><span class="line">a336def9-848d-4a77-a9e1-1805fd9a8a4e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>扁平化数据处理</title>
      <link href="/2019/03/03/%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2019/03/03/%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。</p><a id="more"></a><h4 id="给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。"><a href="#给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。" class="headerlink" title="给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。"></a>给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。</h4><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>输入: [[1,1],2,[1,1]]</p><p>输出: [1,1,2,1,1]</p><p>解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是:[1,1,2,1,1]。</p><h4 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h4><p> 输入: [1,[4,[6]]]</p><p> 输出: [1,4,6]</p><p> 解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 可以利用栈递归实现，依次判断各元素是否为空或者元素类型，递归调用输出，注意内存溢出</p><h4 id="用javascript实现"><a href="#用javascript实现" class="headerlink" title="用javascript实现"></a>用javascript实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var returnItems = [];</span><br><span class="line"><span class="keyword">function</span> Main(listArray) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt;= listArray.length - 1; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof (listArray[i]) === <span class="string">'number'</span>) &#123;</span><br><span class="line">            returnItems.push(listArray[i]);</span><br><span class="line">            console.log(returnItems.pop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Main(listArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list = new Array();</span><br><span class="line">list = [1,[2,[5,7]],3,4];</span><br><span class="line">Main(list);</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class NestedIterator &#123;</span><br><span class="line">constructor(list = []) &#123;</span><br><span class="line">this.currArray = list;</span><br><span class="line">this.currArray.currIndex = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  flat(list) &#123;</span><br><span class="line">    this.currArray = list;</span><br><span class="line">    const currIndex = list.currIndex;</span><br><span class="line">    <span class="built_in">let</span> value = list[ currIndex ];</span><br><span class="line"></span><br><span class="line">    list.currIndex = currIndex + 1;</span><br><span class="line">    <span class="keyword">if</span> (Object.prototype.toString.call(value).slice(8, -1) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">      this.currArray = value;</span><br><span class="line">      this.currArray.parent = list;</span><br><span class="line">      this.currArray.currIndex = 0;</span><br><span class="line">      value = this.flat(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (this.currArray.currIndex &gt;= this.currArray.length &amp;&amp; this.currArray.parent) &#123;</span><br><span class="line">      const parent = this.currArray.parent;</span><br><span class="line">      this.currArray.parent = null;</span><br><span class="line">      this.currArray = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">hasNext</span></span>() &#123;</span><br><span class="line">    const currArray = this.currArray;</span><br><span class="line">    <span class="keyword">if</span> (currArray.currIndex &lt; currArray.length) &#123;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!this.hasNext()) &#123;</span><br><span class="line">      throw new Error(<span class="string">'已经没有值了'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> this.flat(this.currArray);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const nestedList = [1, 2, [3, 4, [5]], [6, [7, 8], [9, 10]]];</span><br><span class="line"><span class="built_in">let</span> i = new NestedIterator(nestedList);</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">  console.log(i.next());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="用java实现"><a href="#用java实现" class="headerlink" title="用java实现"></a>用java实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * // This is the interface that allows <span class="keyword">for</span> creating nested lists.</span><br><span class="line"> * // You should not implement it, or speculate about its implementation</span><br><span class="line"> * class NestedInteger &#123;</span><br><span class="line"> *   public:</span><br><span class="line"> *     // Return <span class="literal">true</span> <span class="keyword">if</span> this NestedInteger holds a single <span class="built_in">integer</span>, rather than a nested list.</span><br><span class="line"> *     bool isInteger() const;</span><br><span class="line"> *</span><br><span class="line"> *     // Return the single <span class="built_in">integer</span> that this NestedInteger holds, <span class="keyword">if</span> it holds a single <span class="built_in">integer</span></span><br><span class="line"> *     // The result is undefined <span class="keyword">if</span> this NestedInteger holds a nested list</span><br><span class="line"> *     int getInteger() const;</span><br><span class="line"> *</span><br><span class="line"> *     // Return the nested list that this NestedInteger holds, <span class="keyword">if</span> it holds a nested list</span><br><span class="line"> *     // The result is undefined <span class="keyword">if</span> this NestedInteger holds a single <span class="built_in">integer</span></span><br><span class="line"> *     const vector&lt;NestedInteger &amp;getList() const;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class NestedIterator &#123;</span><br><span class="line">public:</span><br><span class="line">NestedIterator(vector&lt;NestedInteger &amp;nestedList) &#123;</span><br><span class="line">ini(nestedList, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ini(vector&lt;NestedInteger nestedList,stack&lt;int &amp;vec) &#123;</span><br><span class="line"><span class="keyword">for</span> (int i = nestedList.size()-1; i =0 ; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (nestedList[i].isInteger()) vec.push(nestedList[i].getInteger());</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ini(nestedList[i].getList(),vec);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">next</span></span>() &#123;</span><br><span class="line">int tmp = vec.top();</span><br><span class="line">vec.pop();</span><br><span class="line"><span class="built_in">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool <span class="function"><span class="title">hasNext</span></span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (vec.empty()) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">stack&lt;int vec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your NestedIterator object will be instantiated and called as such:</span><br><span class="line"> * NestedIterator i(nestedList);</span><br><span class="line"> * <span class="keyword">while</span> (i.hasNext()) cout &lt;&lt; i.next();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建hexo网站踩坑点</title>
      <link href="/2019/02/14/%E6%90%AD%E5%BB%BAhexo%E7%BD%91%E7%AB%99%E8%B8%A9%E5%9D%91%E7%82%B9/"/>
      <url>/2019/02/14/%E6%90%AD%E5%BB%BAhexo%E7%BD%91%E7%AB%99%E8%B8%A9%E5%9D%91%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>20190214初识hexo框架，以下为踩坑点<br><a id="more"></a></p><h2 id="前提-安装了node-和-git"><a href="#前提-安装了node-和-git" class="headerlink" title="前提: 安装了node 和 git"></a>前提: 安装了node 和 git</h2><h3 id="一：-安装-hexo脚手架"><a href="#一：-安装-hexo脚手架" class="headerlink" title="一： 安装 hexo脚手架"></a>一： 安装 hexo脚手架</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br></pre></td></tr></table></figure><h4 id="会出现以下信息："><a href="#会出现以下信息：" class="headerlink" title="会出现以下信息："></a>会出现以下信息：</h4><h5 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error: EACCES: permission denied, access <span class="string">'/usr/local/lib/node_modules'</span></span><br><span class="line">npm ERR!  &#123; Error: EACCES: permission denied, access <span class="string">'/usr/local/lib/node_modules'</span></span><br><span class="line">npm ERR!   stack: <span class="string">'Error: EACCES: permission denied, access \'</span>/usr/<span class="built_in">local</span>/lib/node_modules\<span class="string">''</span>,</span><br><span class="line">npm ERR!   errno: -13,</span><br><span class="line">npm ERR!   code: <span class="string">'EACCES'</span>,</span><br><span class="line">npm ERR!   syscall: <span class="string">'access'</span>,</span><br><span class="line">npm ERR!   path: <span class="string">'/usr/local/lib/node_modules'</span> &#125;</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Please try running this <span class="built_in">command</span> again as root/Administrator.</span><br><span class="line">npm ERR! A complete <span class="built_in">log</span> of this run can be found <span class="keyword">in</span>:</span><br><span class="line">npm ERR!     /Users/nieyuling/.npm/_logs/2019-02-14T07_10_39_923Z-debug.log</span><br></pre></td></tr></table></figure><h4 id="原因：-permission-denied-mac电脑没有权限，-需加-sudo-将安装命令改为"><a href="#原因：-permission-denied-mac电脑没有权限，-需加-sudo-将安装命令改为" class="headerlink" title="原因： permission denied, mac电脑没有权限， 需加 sudo, 将安装命令改为"></a>原因： permission denied, mac电脑没有权限， 需加 sudo, 将安装命令改为</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install hexo -g</span><br></pre></td></tr></table></figure><hr><h5 id="2"><a href="#2" class="headerlink" title="2)"></a>2)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Error: EACCES: permission denied, mkdir <span class="string">'/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/build'</span></span><br><span class="line">gyp ERR! System Darwin 18.2.0</span><br><span class="line">gyp ERR! <span class="built_in">command</span> <span class="string">"/usr/local/bin/node"</span> <span class="string">"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js"</span> <span class="string">"configure"</span> <span class="string">"--fallback-to-build"</span> <span class="string">"--module=/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node"</span> <span class="string">"--module_name=fse"</span> <span class="string">"--module_path=/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64"</span> <span class="string">"--napi_version=3"</span> <span class="string">"--node_abi_napi=napi"</span></span><br><span class="line">gyp ERR! cwd /usr/<span class="built_in">local</span>/lib/node_modules/hexo-cli/node_modules/fsevents</span><br><span class="line">gyp ERR! node -v v8.11.3</span><br><span class="line">gyp ERR! node-gyp -v v3.6.2</span><br><span class="line">gyp ERR! not ok</span><br><span class="line">node-pre-gyp ERR! build error</span><br></pre></td></tr></table></figure><h4 id="原因：-permission-denied，-同样是没有权限"><a href="#原因：-permission-denied，-同样是没有权限" class="headerlink" title="原因： permission denied， 同样是没有权限"></a>原因： permission denied， 同样是没有权限</h4><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><p>可用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R <span class="variable">$USER</span> /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p><p>扩大权限，再重新执行一次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br></pre></td></tr></table></figure></p><p>即可</p><hr><h3 id="二：安装成功以后"><a href="#二：安装成功以后" class="headerlink" title="二：安装成功以后"></a>二：安装成功以后</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folderName&gt;</span><br><span class="line"> <span class="comment">#执行时，此folder中会装入很多hexo配置文件和主题文件，文件目录应为一个子文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt; <span class="comment">#进入到hexo的文件中</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo install <span class="comment"># 安装依赖包</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">$ hexo server <span class="comment">#启动服务，默认在http://localhost:4000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
